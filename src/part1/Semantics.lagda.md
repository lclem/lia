---
title: "Syntax and semantics of propositional logic üöß"
---

In this chapter we introduce the syntax of propositional logic.

```
{-# OPTIONS --allow-unsolved-metas --rewriting --confluence-check #-} -- 
open import part0.index

module part1.Semantics (n' : ‚Ñï) where
```

# Syntax

## Propositions {#prop-var}

The main building blocks of propositional logic are *propositional variables* $p, q, \dots$ (a.k.a. propositions),
and logical connectives (to be introduced in the next section).
Propositional variables can be implemented in a variety of ways,
such as strings "p", "q",...;
numbers 0, 1, ...; and many more.
Any such concrete representation will do,
provided that

* We can decide whether two given propositions are equal, and
* We can enumerate all propositions.

Our choice is to represent propositional variables with the datatype !remoteRef(part0)(Finite)(Fin).
The module parameter `n' : ‚Ñï` allows us to name a fixed but arbitrary number of distinct propositions,
leading to the following definition (we omit the type annotation `Set`).

```
n = 3 + n'
PropName = Fin n
```

In examples, we use !ref(p‚ÇÄ), !ref(p‚ÇÅ), and !ref(p‚ÇÇ) as the following concrete variables [^10+n]:

```
p‚ÇÄ p‚ÇÅ p‚ÇÇ : PropName
p‚ÇÄ = fzero
p‚ÇÅ = fsuc fzero 
p‚ÇÇ = fsuc (fsuc fzero)
```

[^10+n]:
    With the simpler and perhaps more natural definition `PropName = Fin n‚Ä≤`
    we would not be able to name any specific proposition such as `p = fzero`
    since `n‚Ä≤` is arbitrary and in particular it could be `0`,
    i.e., there could be no proposition at all.


We use !ref(p), !ref(q), and !ref(r) as generic variable names,
which will be abstracted automatically as implicit arguments:

```
private
  variable
    p q r : PropName
```

Since propositions are modelled with !remoteRef(part0)(Finite)(Fin),
they inherit all the properties of the latter.
In particular, they enjoy decidable equality as initially required,

```
_ : p‚ÇÄ ‚â°? p‚ÇÄ ‚â° yes _
_  = refl

_ : p‚ÇÄ ‚â°? p‚ÇÅ ‚â° no _
_  = refl
```

and they can also be enumerated:

```
propNames : PropName *
propNames = enum

findPropName : ‚àÄ p ‚Üí p ‚àà propNames
findPropName = find
```

For example, the first variable in the enumeration is !ref(p‚ÇÄ) and the second is !ref(p‚ÇÅ):

```
_ : findPropName p‚ÇÄ ‚â° here
_ = refl

_ : findPropName p‚ÇÅ ‚â° there here
_ = refl
```

## Formulas

Formulas of propositional logic are constructed according to the following abstract syntax:

  $$ \varphi, \psi ‚à∑\equiv p \mid \bot \mid \top \mid \neg p \mid \varphi \land \psi \mid \varphi \lor \psi \mid \varphi \Rightarrow \psi \mid \varphi \Leftrightarrow \psi. $$

In other words, a formula is either

* a propositional variable $p$, or
* the *false* constant $\bot$ (pronounced "bottom"), or
* the *true* constant $\top$ (pronounced "top"), or
* the *negation* $\neg \varphi$ of a formula $\varphi$, or
* the *conjunction* $\varphi \land \psi$ of two formulas $\varphi, \psi$, or
* the *disjunction* $\varphi \lor \psi$ of two formulas $\varphi, \psi$, or
* the *implication*[^implication-symbol] $\varphi \Rightarrow \psi$ of two formulas $\varphi, \psi$, or
* the *bi-implication* $\varphi \Leftrightarrow \psi$ of two formulas $\varphi, \psi$.

[^implication-symbol]: Other commonly used symbols for implication are "$\to$"
(which conflicts with Agda's function space constructor `‚Üí` and thus must be avoided),
and the old-fashioned "$\supset$" (which conflicts with common sense,
since in terms of the subset relation, and implication is more akin to "$‚äÜ$").

This straightforwardly translates to the following inductive type:

```
data Formula : Set where
    ‚ä• ‚ä§ : Formula
    `_ : (p : PropName) ‚Üí Formula
    ¬¨_ : (œÜ : Formula) ‚Üí Formula
    _‚à®_ _‚àß_ _‚áí_ _‚áî_ : (œÜ œà : Formula) ‚Üí Formula

private
  variable
    œÜ œà : Formula
```

Note that there is a slight notation overload for variables `` ` p`` w.r.t. the pure mathematical syntax $p$
since we have to explicitly name the `` `_ `` constructor. The syntax for the other connectives is identical.

We follow standard notational conventions and assume that !ref(Formula)(¬¨_) is the operator with the highest priority
(i.e., it binds tighter than any other operator),
followed by !ref(Formula)(_‚àß_), !ref(Formula)(_‚à®_) and !ref(Formula)(_‚áí_), and !ref(Formula)(_‚áî_):

```
infix 100 `_
infix 99 ¬¨_
infixr 98 _‚àß_
infixr 97 _‚à®_ _‚áí_
infixr 96 _‚áî_
```

All binary operators are right associative.
For instance, the formula

```
œÜ‚ÇÄ = ` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÄ ‚à® ` p‚ÇÅ
```

is syntactically identical to the formula

```
œÜ‚ÇÅ = ` p‚ÇÄ ‚à® ((¬¨ ` p‚ÇÄ) ‚à® ` p‚ÇÅ)
```

## Equality

From time to time we need to check whether two formulas are syntactically equal,
i.e., are the very same formula.
For example, `` ` p ‚à® ` q`` is syntactically equal to itself,
but it is different from `` ` q ‚à® ` p``.
A na√Øve way to decide equality would be to list all the 8 √ó 8 = 64 pairs of constructors,

    instance eqFormula : Eq (Formula)
    _‚â°?_ {{eqFormula}} = go where
      go : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚â° œà)
      go ‚ä§ ‚ä§ = yes refl
      go ‚ä§ ‚ä• = no Œª ()
      go ‚ä§ (` _) = no Œª ()
    ...

which is not practical [^no-split-on-catchall].
We will follow another, more interesting route.

1. First, we create an enumeration for the logical connectives,
for which we can easily prove decidability of equality.

2. Then, we injectively map formulas to labelled trees,
for which decidable equality is easier to prove [^dec-eq-reference].

[^no-split-on-catchall]:
    The issue is that Agda does not perform splits on a catch-all pattern `_`,
    thus preventing the following intuitive linear-sized code from working:
  
        instance eqFormula : Eq (Formula)
        _‚â°?_ {{eqFormula}} = go where
          go : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚â° œà)
          go ‚ä§ ‚ä§ = yes refl
          go ‚ä§ _ = no (Œª ())
        ...
    This seems to be an often-made [complaint](https://github.com/agda/agda/issues/4804) about Agda.

[^dec-eq-reference]: We present a solution inspired from a discussion on
[stackoverflow](https://stackoverflow.com/questions/45150324/decidable-equality-in-agda-with-less-than-n2-cases).

**Step 1**.
We begin by defining an enumeration type for the formula constructors (connectives).

```
data Connective : Set where
  True False Not And Or Implies Iff : Connective
```

We can injectively map elements of `Connective` to the natural numbers `‚Ñï` in the obvious way.

```
c2‚Ñï : Connective ‚Üí ‚Ñï
c2‚Ñï True = 0
c2‚Ñï False = 1
c2‚Ñï Not = 2
c2‚Ñï And = 3
c2‚Ñï Or = 4
c2‚Ñï Implies = 5
c2‚Ñï Iff = 6
```

Thanks to pattern matching,
we only need to consider 7 cases (linearly many in the number of constructors of `Formula`)
to show that `c2‚Ñï` is injective:

```
c2‚Ñï-inj : Injective c2‚Ñï
c2‚Ñï-inj True True _ = refl
c2‚Ñï-inj False False _ = refl
c2‚Ñï-inj Not Not _ = refl
c2‚Ñï-inj And And _ = refl
c2‚Ñï-inj Or Or _ = refl
c2‚Ñï-inj Implies Implies _ = refl
c2‚Ñï-inj Iff Iff _ = refl
```

Since equality is decidable on natural numbers `‚Ñï`
and `Connective` maps injectively to `‚Ñï`,
equality is decidable for `Connective` as well.

```
instance eqConnective : Eq Connective
_‚â°?_ {{eqConnective}} = go where

  go : ‚àÄ C1 C2 ‚Üí Dec (C1 ‚â° C2)
  go C1 C2 with c2‚Ñï C1 ‚â°? c2‚Ñï C2
  -- by injectivity
  ... | yes eq = yes (c2‚Ñï-inj C1 C2 eq)
  -- by functionality
  ... | no neq = no Œª{refl ‚Üí neq refl}
```

**Step 2**.
We now injectively map formulas to `Connective ‚äé PropName`-labelled trees.
Since `Connective` and `PropName` have decidable equality,
so does their tagged union `Connective ‚äé VarName`.

```
FormulaTree = Tree (Connective ‚äé PropName)
```

We map formulas to trees by structural induction as follows:

```
Formula2Tree : Formula ‚Üí FormulaTree
Formula2Tree ‚ä§ = Node (left True) Œµ
Formula2Tree ‚ä• = Node (left False) Œµ
Formula2Tree (` p) = Node (right p) Œµ
Formula2Tree (¬¨ œÜ) = Node (left Not) ([ (Formula2Tree œÜ) ])
Formula2Tree (œÜ ‚à® œà) = Node (left Or) ([ (Formula2Tree œÜ) (Formula2Tree œà) ])
Formula2Tree (œÜ ‚àß œà) = Node (left And) ([ (Formula2Tree œÜ) (Formula2Tree œà) ])
Formula2Tree (œÜ ‚áí œà) = Node (left Implies) ([ (Formula2Tree œÜ) (Formula2Tree œà) ])
Formula2Tree (œÜ ‚áî œà) = Node (left Iff) ([ (Formula2Tree œÜ) (Formula2Tree œà) ])
```

!exercise(#exercise:Formula2Tree-inj)(`Formula2Tree-inj`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that the mapping `Formula2Tree` is injective.

```
Formula2Tree-inj : Injective Formula2Tree
```

*Hint:* Exploit the fact that the list constructor `_‚à∑_` is injective on both arguments
(c.f. !remoteRef(part0)(List)(‚à∑-inj-left) and !remoteRef(part0)(List)(‚à∑-inj-right) from !chapterRef(part0)(List)).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
Formula2Tree-inj ‚ä§ ‚ä§ _ = refl
Formula2Tree-inj ‚ä• ‚ä• _ = refl
Formula2Tree-inj (` p) (` p) refl = refl
Formula2Tree-inj (¬¨ a) (¬¨ b) eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql))
... | refl = refl
Formula2Tree-inj (œÜ ‚àß œà) (œÜ' ‚àß œà') eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql)) |
       Formula2Tree-inj _ _ (‚à∑-inj-left (‚à∑-inj-right (Node-inj-right eql)))
... | refl | refl = refl
Formula2Tree-inj (œÜ ‚à® œà) (œÜ' ‚à® œà') eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql)) |
       Formula2Tree-inj _ _ (‚à∑-inj-left (‚à∑-inj-right (Node-inj-right eql)))
... | refl | refl = refl
Formula2Tree-inj (œÜ ‚áí œà) (œÜ' ‚áí œà') eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql)) |
       Formula2Tree-inj _ _ (‚à∑-inj-left (‚à∑-inj-right (Node-inj-right eql)))
... | refl | refl = refl
Formula2Tree-inj (œÜ ‚áî œà) (œÜ' ‚áî œà') eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql)) |
       Formula2Tree-inj _ _ (‚à∑-inj-left (‚à∑-inj-right (Node-inj-right eql)))
... | refl | refl = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With this ingredients in hand,
we can show that `Formula` has decidable equality:

```
instance eqFormula : Eq Formula
_‚â°?_ {{eqFormula}} = go where
  
    go : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚â° œà)
    go œÜ œà with Formula2Tree œÜ ‚â°? Formula2Tree œà
    ... | yes eq = yes (Formula2Tree-inj _ _ eq)
    ... | no neq = no Œª{refl ‚Üí neq refl}
```

!example(#example:equality)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We demonstrate decidability of formula equality. We have

```
_ : (` p‚ÇÄ ‚à® ` p‚ÇÅ ‚â°? ` p‚ÇÄ ‚à® ` p‚ÇÅ) ‚â° yes _
_ = refl
```

but

```
_ : (` p‚ÇÄ ‚à® ` p‚ÇÅ ‚â°? ` p‚ÇÅ ‚à® ` p‚ÇÄ) ‚â° no _
_ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Semantics

In this section we introduce the semantics of classical logic.

## Valuations

An *valuation* is a mapping that associates a Boolean value !remoteRef(part0)(Booleans)(ùîπ) to each propositional variable.
We use !ref(œ±) and !ref(œ±‚Ä≤) for indicating a generic valuation.

```
Val = PropName ‚Üí ùîπ

variable œ± œ±‚Ä≤ : Val
```

The two simplest valuations, and the least interesting,
are those which assign a constant truth value to every proposition:

```
œ±tt œ±ff : Val
œ±tt = const tt
œ±ff = const ff
```

As marginally more interesting example,
the valuation !ref(œ±‚ÇÄ) below
assigns !remoteRef(part0)(Booleans)(ùîπ)(ff) to `p‚ÇÄ` and `p‚ÇÅ`, and !remoteRef(part0)(Booleans)(ùîπ)(tt) to every other variable:

```
œ±‚ÇÄ : Val
œ±‚ÇÄ = œ±tt [ p‚ÇÄ ‚Ü¶ ff ] [ p‚ÇÅ ‚Ü¶ ff ]
```

Since both propositions !ref(PropName) and Boolean values !remoteRef(part0)(Booleans)(ùîπ) can be enumerated,
the same holds true for valuations !ref(Val),
which will be very useful to show that propositional logic is decidable.

```
vals : Val *
vals = enum

findVal : ‚àÄ œ± ‚Üí œ± ‚àà vals
findVal = find
```

## Semantics of propositional formulas

The semantics `‚ü¶ œÜ ‚üß œ± : ùîπ` of a formula `œÜ : Formula` in a given valuation `œ± : Val`
is a Boolean value (a.k.a. *truth value*) which is determined by
structural induction on `œÜ`:

* In the base cases !ref(Formula)(‚ä§) and !ref(Formula)(‚ä•),
the semantics is the corresponding truth value !remoteRef(part0)(Booleans)(ùîπ)(tt), resp., !remoteRef(part0)(Booleans)(ùîπ)(ff).
* In the variable case `` ` p ``, the semantics is `œ± p` as provided by the valuation `œ±`.
* In the negation case `¬¨ œÜ`, we inductively compute the semantics `‚ü¶ œÜ ‚üß œ±` of `œÜ`,
and then we apply the Boolean negation function [`¬¨ùîπ_ : ùîπ ‚Üí ùîπ`](../../part0/Booleans#¬¨ùîπ_).
* The remaining cases `œÜ ‚àß œà`, `œÜ ‚à® œà`, `œÜ ‚áí œà`, and `œÜ ‚áî œà` are similar.

Formally, we have the following definition:

```
infix 200 ‚ü¶_‚üß_

‚ü¶_‚üß_ : Formula ‚Üí Val ‚Üí ùîπ
‚ü¶ ‚ä• ‚üß œ± = ff
‚ü¶ ‚ä§ ‚üß œ± = tt
‚ü¶ ` p ‚üß œ± = œ± p
‚ü¶ ¬¨ œÜ ‚üß œ± = ¬¨ùîπ ‚ü¶ œÜ ‚üß œ±
‚ü¶ œÜ ‚àß œà ‚üß œ± = ‚ü¶ œÜ ‚üß œ± ‚àßùîπ ‚ü¶ œà ‚üß œ±
‚ü¶ œÜ ‚à® œà ‚üß œ± = ‚ü¶ œÜ ‚üß œ± ‚à®ùîπ ‚ü¶ œà ‚üß œ±
‚ü¶ œÜ ‚áí œà ‚üß œ± = ‚ü¶ œÜ ‚üß œ± ‚áíùîπ ‚ü¶ œà ‚üß œ±
‚ü¶ œÜ ‚áî œà ‚üß œ± = ‚ü¶ œÜ ‚üß œ± ‚áîùîπ ‚ü¶ œà ‚üß œ±
```

!example(#example:semantics)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For example, we can compute the semantics of some simple formulas
(recall that both !ref(p‚ÇÄ) and !ref(p‚ÇÅ) evaluate to !remoteRef(part0)(Booleans)(ff) under !ref(œ±‚ÇÄ)):

```
_ : ‚ü¶ ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ ‚üß œ±‚ÇÄ ‚â° ff
_ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Invariance of the semantics

The semantics `‚ü¶ œÜ ‚üß œ±` of a formula `œÜ` depends on the valuation `œ±`.
However, if a formula `œÜ` does not contain a certain proposition `p`
then clearly the value `œ± p` of `œ±` on `p` should not matter.
We now formalise this intuition by showing
that the semantics depends only on the propositional variables actually occurring in the formula.

We first compute the list `props œÜ` of occurrences of propositions in `œÜ`.
We proceed by structural induction on the formula:

```
props : Formula ‚Üí PropName *
props ‚ä§ = Œµ
props ‚ä• = Œµ
props (` p) = [ p ]
props (¬¨ œÜ) = props œÜ
props (œÜ ‚àß œà) = props œÜ ++ props œà
props (œÜ ‚à® œà) = props œÜ ++ props œà
props (œÜ ‚áí œà) = props œÜ ++ props œà
props (œÜ ‚áî œà) = props œÜ ++ props œà
```

Notice that `props œÜ` is an ordered *list* of all the occurrences of propositions in `œÜ`,
and thus contains duplicated elements if the same proposition appears multiple times.
For instance,

```
_ : props œÜ‚ÇÄ ‚â° [ p‚ÇÄ p‚ÇÄ p‚ÇÅ ]
_ = refl
```

A more natural idea would be to compute the *set* $\{ p , q \}$ of all propositions occurring in `œÜ‚ÇÄ`,
i.e., without duplications (and modulo commutativity). However 1) this would be more cumbersome to represent,
and 2) the current definition is good enough for most use cases of `props`.

We say that a proposition `p` is *fresh* w.r.t. `œÜ`
if `p` does not occur in `props œÜ`.

We can now formulate the invariance of the semantics.
Intuitively, if two valuations `œ±` and `œ±‚Ä≤` agree (i.e., have the same value)
on the propositions `props œÜ` occurring in `œÜ`,
then the semantics is the same:

```
invariance : ‚àÄ œÜ ‚Üí
  Agree œ± œ±‚Ä≤ (props œÜ) ‚Üí
  ------------------
  ‚ü¶ œÜ ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ±‚Ä≤
```

!exercise(#exercise:invariance)(`invariance`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove invariance of the semantics.
*Hint*: Proceed by structural induction on formulas. In the variable case, use the assumption `Agree œ± œ±‚Ä≤ (props œÜ)`.
In the inductive cases, use the fact that if `œ±` and `œ±‚Ä≤` agree on their value on the propositions in `œÜ ‚àß œà`,
then they do so on `œÜ`, resp., `œà`.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
invariance ‚ä§ agree = refl
invariance ‚ä• agree = refl
invariance (` p) agree = agree here
invariance (¬¨ œÜ) agree
  rewrite invariance œÜ agree = refl
invariance (œÜ ‚àß œà) agree
  rewrite invariance œÜ (Agree-‚äÜ agree ‚äÜ-++-left) |
          invariance œà (Agree-‚äÜ agree (‚äÜ-++-right (props œÜ))) = refl
invariance (œÜ ‚à® œà) agree
  rewrite invariance œÜ (Agree-‚äÜ agree ‚äÜ-++-left) |
          invariance œà (Agree-‚äÜ agree (‚äÜ-++-right (props œÜ))) = refl
invariance (œÜ ‚áí œà) agree
  rewrite invariance œÜ (Agree-‚äÜ agree ‚äÜ-++-left) |
          invariance œà (Agree-‚äÜ agree (‚äÜ-++-right (props œÜ))) = refl
invariance (œÜ ‚áî œà) agree
  rewrite invariance œÜ (Agree-‚äÜ agree ‚äÜ-++-left) |
          invariance œà (Agree-‚äÜ agree (‚äÜ-++-right (props œÜ))) = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:coincidence)(`coincidence`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the following *concidence lemma*
stating that the semantics of a formula `œÜ` does not change
if we update the value of the valuation `œ±` on a proposition `p`
not occurring in `œÜ`.

```
coincidence : ‚àÄ {b} œÜ ‚Üí
  p ‚àâ props œÜ ‚Üí
  ---------------------------
  ‚ü¶ œÜ ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ± [ p ‚Ü¶ b ]
```

*Hint* : Use invariance of the semantics.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
coincidence {p} {œ±} {b} œÜ p‚àâœÜ = invariance œÜ agree where

  agree : Agree œ± (œ± [ p ‚Ü¶ b ]) (props œÜ)
  agree = Agree-update-~‚àà (‚àâ‚Üí~‚àà p‚àâœÜ)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Substitution lemma

A basic operation on formulas is *substitution* of a propositional variable with another formula.

```
infix 101 _F[_‚Ü¶_]
_F[_‚Ü¶_] : Formula ‚Üí PropName ‚Üí Formula ‚Üí Formula
```

Intuitively, `œÜ F[ p ‚Ü¶ œà ]` is obtained from the formula `œÜ`
by replacing every occurrence of proposition `p` with `œà`.
Substitution binds tighter than !ref(Formula) constructors[^substitution-notation],
e.g., `¬¨ œÜ F[ p ‚Ü¶ Œæ ] ‚â° ¬¨ (œÜ F[ p ‚Ü¶ Œæ ])`.
The definition of substitution follows a natural structural induction:

<!--
```
_ : ‚àÄ œÜ p Œæ ‚Üí
  ----------------------------------
  ¬¨ œÜ F[ p ‚Ü¶ Œæ ] ‚â° ¬¨ (œÜ F[ p ‚Ü¶ Œæ ])

_ = Œª _ _ _ ‚Üí refl
```
-->

[^substitution-notation]: Recall that the similar notation !remoteRef(part0)(Functions)(_[_‚Ü¶_]) is reserved for function updates.

```
‚ä§ F[ _ ‚Ü¶ Œæ ] = ‚ä§
‚ä• F[ p ‚Ü¶ Œæ ] = ‚ä•
(` q) F[ p ‚Ü¶ Œæ ] with p ‚â°? q
... | yes _ = Œæ
... | no _ = ` q
(¬¨ œÜ) F[ p ‚Ü¶ Œæ ] = ¬¨ œÜ F[ p ‚Ü¶ Œæ ]
(œÜ ‚àß œà) F[ p ‚Ü¶ Œæ ] = œÜ F[ p ‚Ü¶ Œæ ] ‚àß œà F[ p ‚Ü¶ Œæ ]
(œÜ ‚à® œà) F[ p ‚Ü¶ Œæ ] = œÜ F[ p ‚Ü¶ Œæ ] ‚à® œà F[ p ‚Ü¶ Œæ ]
(œÜ ‚áí œà) F[ p ‚Ü¶ Œæ ] = œÜ F[ p ‚Ü¶ Œæ ] ‚áí œà F[ p ‚Ü¶ Œæ ]
(œÜ ‚áî œà) F[ p ‚Ü¶ Œæ ] = œÜ F[ p ‚Ü¶ Œæ ] ‚áî œà F[ p ‚Ü¶ Œæ ]
```

!example(#example:substitution)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We have

```
_ : (` p‚ÇÄ ‚à® ` p‚ÇÅ) F[ p‚ÇÅ ‚Ü¶ ` p‚ÇÅ ‚à® ` p‚ÇÇ ] ‚â° ` p‚ÇÄ ‚à® ` p‚ÇÅ ‚à® ` p‚ÇÇ
_ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:parallel-substitution)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
From time to time it is useful to substitute in parallel two propositions `p` and `q` by `œà`, resp., `Œæ`,
written `œÜ F2[ p , q ‚Ü¶ œà , Œæ ]`.
For example, `` ` p‚ÇÄ ‚à® ` p‚ÇÅ F2[ p‚ÇÄ , p‚ÇÅ ‚Ü¶ p‚ÇÅ , p‚ÇÄ ] ‚â° ` p‚ÇÅ ‚à® ` p‚ÇÄ ``.
Provide a definition of parallel substitution:

```
infix 101 _F2[_,_‚Ü¶_,_]
_F2[_,_‚Ü¶_,_] : Formula ‚Üí PropName ‚Üí PropName ‚Üí Formula ‚Üí Formula ‚Üí Formula
```

What happens if `p ‚â° q` ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
‚ä• F2[ p , q ‚Ü¶ œà , Œæ ] = ‚ä•

‚ä§ F2[ p , q ‚Ü¶ œà , Œæ ] = ‚ä§

(` r) F2[ p , q ‚Ü¶ œà , Œæ ]
  with p ‚â°? r
... | yes _ = œà
... | no _
  with q ‚â°? r
... | yes _ = Œæ
... | no _ = ` r

(¬¨ œÜ) F2[ p , q ‚Ü¶ œà , Œæ ] = ¬¨ œÜ F2[ p , q ‚Ü¶ œà , Œæ ]

(œÜ‚ÇÅ ‚àß œÜ‚ÇÇ) F2[ p , q ‚Ü¶ œà , Œæ ] = œÜ‚ÇÅ F2[ p , q ‚Ü¶ œà , Œæ ] ‚àß œÜ‚ÇÇ F2[ p , q ‚Ü¶ œà , Œæ ]

(œÜ‚ÇÅ ‚à® œÜ‚ÇÇ) F2[ p , q ‚Ü¶ œà , Œæ ] = œÜ‚ÇÅ F2[ p , q ‚Ü¶ œà , Œæ ] ‚à® œÜ‚ÇÇ F2[ p , q ‚Ü¶ œà , Œæ ]

(œÜ‚ÇÅ ‚áí œÜ‚ÇÇ) F2[ p , q ‚Ü¶ œà , Œæ ] = œÜ‚ÇÅ F2[ p , q ‚Ü¶ œà , Œæ ] ‚áí œÜ‚ÇÇ F2[ p , q ‚Ü¶ œà , Œæ ]

(œÜ‚ÇÅ ‚áî œÜ‚ÇÇ) F2[ p , q ‚Ü¶ œà , Œæ ] = œÜ‚ÇÅ F2[ p , q ‚Ü¶ œà , Œæ ] ‚áî œÜ‚ÇÇ F2[ p , q ‚Ü¶ œà , Œæ ]
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The main property of substitution regards its interaction with the semantics.
This is expressed by the following *substitution lemma*:

```
substitution : ‚àÄ œÜ p Œæ œ± ‚Üí
  --------------------------------------------
  ‚ü¶ œÜ F[ p ‚Ü¶ Œæ ] ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ± [ p ‚Ü¶ ‚ü¶ Œæ ‚üß œ± ]
```

Intuitively, the substitution lemma says that we can implement a syntactical substitution with a suitable update of the valuation.
One could say that the substitution lemma shows a certain *commutation rule* between substitution and evaluation.

!exercise(#exercise:substitution)(`substitution`) 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the substitution lemma.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
substitution ‚ä§ p Œæ œ± = refl
substitution ‚ä• p Œæ œ± = refl
substitution (` q) p Œæ œ± with p ‚â°? q
... | yes refl = refl
... | no _ = refl
substitution (¬¨ œÜ) p Œæ œ± rewrite substitution œÜ p Œæ œ± = refl
substitution (œÜ ‚àß œà) p Œæ œ± rewrite substitution œÜ p Œæ œ± | substitution œà p Œæ œ± = refl
substitution (œÜ ‚à® œà) p Œæ œ± rewrite substitution œÜ p Œæ œ± | substitution œà p Œæ œ± = refl
substitution (œÜ ‚áí œà) p Œæ œ± rewrite substitution œÜ p Œæ œ± | substitution œà p Œæ œ± = refl
substitution (œÜ ‚áî œà) p Œæ œ± rewrite substitution œÜ p Œæ œ± | substitution œà p Œæ œ± = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A *variable renaming* is a special substitution of the form ``œÜ F[ p ‚Ü¶ ` q ]``.
It is convenient to state the substitution lemma in the special case of variable renamings:

```
renamings : ‚àÄ œÜ p q œ± ‚Üí
  ------------------------------------------
  ‚ü¶ œÜ F[ p ‚Ü¶ ` q ] ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ± [ p ‚Ü¶ œ± q ]
  
renamings œÜ p q œ± = substitution œÜ p (` q) œ± 
```

!exercise(#exercise:subst-id)(`subst-id`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that a substitution `œÜ F[ p ‚Ü¶ Œæ ]` does not alter the formula `œÜ`
if the variable `p` does not actually appear in `œÜ`:

```
subst-id : ‚àÄ œÜ p Œæ ‚Üí
  p ~‚àà props œÜ ‚Üí
  ----------------
  œÜ F[ p ‚Ü¶ Œæ ] ‚â° œÜ
```

*Hint:* Proceed by structural induction,
using the assumption `p ~‚àà props œÜ` in the variable case;
the two auxiliary functions !remoteRef(part0)(List)(~‚àà-++-left) and !remoteRef(part0)(List)(~‚àà-++-right) will be useful in the inductive case.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
subst-id ‚ä§ p Œæ p~‚ààœÜ = refl
subst-id ‚ä• p Œæ p~‚ààœÜ = refl
subst-id (` q) p Œæ p~‚ààœÜ with p ‚â°? q
-- contradiction
... | yes refl = F-elim (p~‚ààœÜ here)
... | no _ = refl 
subst-id (¬¨ œÜ) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ p~‚ààœÜ = refl
subst-id (œÜ ‚àß œà) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ (~‚àà-++-left  p~‚ààœÜ) |
          subst-id œà p Œæ (~‚àà-++-right (props œÜ) p~‚ààœÜ) = refl 
subst-id (œÜ ‚à® œà) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ (~‚àà-++-left p~‚ààœÜ) |
          subst-id œà p Œæ (~‚àà-++-right (props œÜ) p~‚ààœÜ) = refl 
subst-id (œÜ ‚áí œà) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ (~‚àà-++-left p~‚ààœÜ) |
          subst-id œà p Œæ (~‚àà-++-right (props œÜ) p~‚ààœÜ) = refl 
subst-id (œÜ ‚áî œà) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ (~‚àà-++-left p~‚ààœÜ) |
          subst-id œà p Œæ (~‚àà-++-right (props œÜ) p~‚ààœÜ) = refl 
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:rename-undo)(`rename-undo`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Let `œÜ : Formula` be a formula and `p q : PropName` two propositions.
Prove that a double substitution ``œÜ F[ p ‚Ü¶ ` q ] F[ q ‚Ü¶ ` p ]`` does not change the formula `œÜ`
if the variable `q` does not occur in `œÜ`:

```
rename-undo : ‚àÄ œÜ p q ‚Üí
  q ‚àâ props œÜ ‚Üí
  --------------------------------
  œÜ F[ p ‚Ü¶ ` q ] F[ q ‚Ü¶ ` p ] ‚â° œÜ
```

**Warning**: `q ‚àâ props œÜ` here is different from `q ~‚àà props œÜ`.
While the latter is just an abbreviation for `~ (q ‚àà props œÜ)`
and thus it provides indirect evidence that `q` is not in `props œÜ`,
the former provides direct evidence that `q` is not in `props œÜ`
and thus it is stronger.
The two happen to be equivalent thanks to the conversion functions
!remoteRef(part0)(List)(~‚àà‚Üí‚àâ) and !remoteRef(part0)(List)(‚àâ‚Üí~‚àà)

*Hint:* Proceed by induction on the evidence `q ‚àâ props œÜ` that `q` is not in `œÜ`.
The auxiliary functions !remoteRef(part0)(List)(‚àâ-++-left) and !remoteRef(part0)(List)(‚àâ-++-right) will be useful in the inductive cases.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
rename-undo ‚ä§ p q q‚àâœÜ = refl
rename-undo ‚ä• p q q‚àâœÜ = refl

rename-undo (` r) p q (notThere q‚â¢r _)
  with refl-‚â°? q
... | q‚â°?q‚â°yes
  with p ‚â°? r
... | yes refl rewrite q‚â°?q‚â°yes = refl 
... | no _
  with q ‚â°? r
... | yes refl = x‚â¢x-elim q‚â¢r
... | no _ = refl 

rename-undo (¬¨ œÜ) p q q‚àâœÜ
  rewrite rename-undo œÜ p q q‚àâœÜ = refl

rename-undo (œÜ ‚àß œà) p q q‚àâœÜ
  rewrite rename-undo œÜ p q (‚àâ-++-left q‚àâœÜ) |
          rename-undo œà p q (‚àâ-++-right {as = props œÜ} q‚àâœÜ)
  = refl
  
rename-undo (œÜ ‚à® œà) p q q‚àâœÜ
  rewrite rename-undo œÜ p q (‚àâ-++-left q‚àâœÜ) |
          rename-undo œà p q (‚àâ-++-right {as = props œÜ} q‚àâœÜ)
  = refl
  
rename-undo (œÜ ‚áí œà) p q q‚àâœÜ
  rewrite rename-undo œÜ p q (‚àâ-++-left q‚àâœÜ) |
          rename-undo œà p q (‚àâ-++-right {as = props œÜ} q‚àâœÜ)
  = refl
  
rename-undo (œÜ ‚áî œà) p q q‚àâœÜ
  rewrite rename-undo œÜ p q (‚àâ-++-left q‚àâœÜ) |
          rename-undo œà p q (‚àâ-++-right {as = props œÜ} q‚àâœÜ)
  = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Tautology, entailment, and equivalence

### Tautology

A *tautology* is a formula that evaluates to !remoteRef(part0)(Booleans)(ùîπ)(tt) under every valuation:

```
Tautology : Formula ‚Üí Set
Tautology œÜ = ‚àÄ[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â° tt
```

For instance the *law of excluded middle* `` ` p ‚à® ¬¨ ` p ``,
which amounts to say that the propositional variable `p` has either the value !remoteRef(part0)(Booleans)(ùîπ)(tt) or !remoteRef(part0)(Booleans)(ùîπ)(ff),
is a tautology of classical logic:

```
LEM : Tautology (` p ‚à® ¬¨ ` p)
LEM {p} œ± with œ± p
... | tt = refl
... | ff = refl
```

On the other hand, `` ` p `` is not a tautology since the (any) valuation that maps `p` to !remoteRef(part0)(Booleans)(ùîπ)(ff), such as `const ff`, does not satisfy it:

```
_ : ~ Tautology (` p)
_ = Œª tau ‚Üí let ff‚â°tt = tau (const ff) in ff‚â¢tt ff‚â°tt
```

Since we can enumerate all valuations `œ± : Val`
and the equality `‚ü¶ œÜ ‚üß œ± ‚â° tt` is decidable,
we can *decide* whether `œÜ` is a tautology:

```
Tautology? : Decidable Tautology
Tautology? œÜ = ‚àÄ?[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â°? tt
```

For instance, we can check by computing that `` ` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÄ `` is a tautology,
and that `` ` p‚ÇÄ ‚à® ` p‚ÇÅ `` is not a tautology,
where !ref(p‚ÇÄ) and !ref(p‚ÇÅ) are two concrete propositions.

```
_ : n ‚â° 3 ‚Üí ‚åû Tautology? (` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÄ) ‚åü ‚â° tt
_ = Œª{refl ‚Üí refl}

_ : n ‚â° 3 ‚Üí ‚åû Tautology? (` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÅ) ‚åü ‚â° ff
_ = Œª{refl ‚Üí refl}
```

(Note that we need to assume that !ref(n) is some concrete number here,
allowing us to actually enumerate all valuations.
 We use the erasure mapping !remoteRef(part0)(Booleans)(‚åû_‚åü) to convert !remoteRef(part0)(Decidable)(Dec)(yes), resp., !remoteRef(part0)(Decidable)(Dec)(no), to !remoteRef(part0)(Booleans)(ùîπ)(tt), resp., !remoteRef(part0)(Booleans)(ùîπ)(ff),
thus discarding the proof of correctness returned by !ref(Tautology?).)

!exercise(#exercise:tautology-substitution)(Tautology and substitution)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Show that if `œÜ` is a tautology, then replacing any propositional variable therein with an arbitrary formula is also a tautology:
```
tautology-subst : ‚àÄ œÜ p œà ‚Üí
  Tautology œÜ ‚Üí
  -------------------------
  Tautology (œÜ F[ p ‚Ü¶ œà ])
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The proof is an immediate application of the substitution lemma:

```
tautology-subst œÜ p œà tau-œÜ œ±
  rewrite substitution œÜ p œà œ± = tau-œÜ (œ± [ p ‚Ü¶ ‚ü¶ œà ‚üß œ± ])
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Entailment and equivalence

We say that a formula `œÜ` *entails* (or *logically implies*) a formula `œà`,
written `œÜ ‚áõ œà`, if every valuation that satisfies `œÜ` satisfies `œà` as well,
and that they are *logically equivalent*, written `œÜ ‚ü∫ œà`,
if they satisfy the same valuations:

```
infix 9 _‚áõ_ _‚ü∫_

_‚áõ_ : Formula ‚Üí Formula ‚Üí Set
œÜ ‚áõ œà = ‚àÄ[ œ± ] (‚ü¶ œÜ ‚üß œ± ‚â° tt ‚Üí ‚ü¶ œà ‚üß œ± ‚â° tt)

_‚ü∫_ : Formula ‚Üí Formula ‚Üí Set
œÜ ‚ü∫ œà =  ‚àÄ[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â° ‚ü¶ œà ‚üß œ±
```

(Although typographically similar,
entailment !ref(_‚áõ_) shoud not be confused with the formula implication constructor [`_‚áí_ : Formula ‚Üí Formula ‚Üí Formula`](#Formula._‚áí_);
the same warning applies to logical equivalence !ref(_‚ü∫_) vs. the bi-implication constructor !ref(Formula)(_‚áî_).)
For the same reasons as for tautology, entailment and equivalence are decidable:

```
_‚áõ?_ : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚áõ œà)
œÜ ‚áõ? œà = ‚àÄ?[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â°? tt ‚Üí? ‚ü¶ œà ‚üß œ± ‚â°? tt

_‚ü∫?_ : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚ü∫ œà)
œÜ ‚ü∫? œà = ‚àÄ?[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â°? ‚ü¶ œà ‚üß œ±
```

For instance, we can check that `` ` p‚ÇÄ `` entails `` ` p‚ÇÄ ‚à® ` p‚ÇÅ ``, but not `` ` p‚ÇÅ ``,
and that `` ` p‚ÇÄ ‚àß ` p‚ÇÅ `` is logically equivalent to `` ` p‚ÇÅ ‚àß ` p‚ÇÄ ``:

```
_ : n ‚â° 3 ‚Üí ‚åû ` p‚ÇÄ ‚áõ? ` p‚ÇÄ ‚à® ` p‚ÇÅ ‚åü ‚â° tt
_ = Œª{refl ‚Üí refl}

_ : n ‚â° 3 ‚Üí ‚åû ` p‚ÇÄ ‚áõ? ` p‚ÇÅ ‚åü ‚â° ff
_ = Œª{refl ‚Üí refl}

_ : n ‚â° 3 ‚Üí ‚åû ` p‚ÇÄ ‚àß ` p‚ÇÅ ‚ü∫? ` p‚ÇÅ ‚àß ` p‚ÇÄ ‚åü ‚â° tt
_ = Œª{refl ‚Üí refl}
```

!exercise(#exercise:entailment-preorder)(Entailment is a preorder)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that the entailment relation is a preorder:

```
refl-‚áõ : ‚àÄ œÜ ‚Üí œÜ ‚áõ œÜ
trans-‚áõ : ‚àÄ œÜ œà Œæ ‚Üí œÜ ‚áõ œà ‚Üí œà ‚áõ Œæ ‚Üí œÜ ‚áõ Œæ
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
refl-‚áõ œÜ _ = id
trans-‚áõ _ _ _ œÜ‚ä®œà œà‚ä®Œæ œ± = œà‚ä®Œæ œ± ‚àò œÜ‚ä®œà œ±
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The fact that entailment is a preodrer implies immediately that logical equivalence is also a prerorder.

```
refl-‚ü∫ : ‚àÄ œÜ ‚Üí œÜ ‚ü∫ œÜ
sym-‚ü∫ : ‚àÄ œÜ œà ‚Üí œÜ ‚ü∫ œà ‚Üí œà ‚ü∫ œÜ
trans-‚ü∫ : ‚àÄ œÜ œà Œæ ‚Üí œÜ ‚ü∫ œà ‚Üí œà ‚ü∫ Œæ ‚Üí œÜ ‚ü∫ Œæ
```

!hide
~~~~~~~~

~~~~~~~~
~~~~~~~~
```
refl-‚ü∫ = {!!}
trans-‚ü∫ = {!!}
sym-‚ü∫ = {!!}
```
~~~~~~~~

There is a simple reprhasing of tautology in terms of logical equivalence.
A formula `œÜ` is a tautology iff it is logically equivalent to !ref(Formula)(‚ä§):

```
tautology-equivalence : ‚àÄ œÜ ‚Üí Tautology œÜ ‚Üî œÜ ‚ü∫ ‚ä§
tautology-equivalence œÜ = (Œª tau œ± ‚Üí tau œ±) , Œª œÜ‚ü∫‚ä§ œ± ‚Üí œÜ‚ü∫‚ä§ œ±
```

While quite evident by itself, the equivalence above does find its applications,
such as in !remoteRef(part1)(CharacteristicFormulas)(duality-tautology).

TODO: put this in context:

```
tautology-impl : 
  Tautology œÜ ‚Üí
  œÜ ‚áõ œà ‚Üí
  ------------
  Tautology œà

tautology-impl = {!   !}
```


The following exercise explores a converse relationship between entailment/equivalnce and tautology.

!exercise(#exercise:entailment-implication)(Entailment and implication)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The typographic similarity betwee entailment and implication,
and similarly for equivalence and bi-implication,
is explained by the following connection with tautology:

```
entailment-implication : ‚àÄ œÜ œà ‚Üí œÜ ‚áõ œà ‚Üî Tautology (œÜ ‚áí œà)
entailment-equivalence : ‚àÄ œÜ œà ‚Üí œÜ ‚ü∫ œà ‚Üî Tautology (œÜ ‚áî œà)
```

Prove the two properties above.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We begin with !ref(entailment-implication).
We break it up into two directions, which are proved separately:

```
entailment-implication-1 : ‚àÄ œÜ œà ‚Üí
  œÜ ‚áõ œà ‚Üí
  ------------------
  Tautology (œÜ ‚áí œà)

entailment-implication-1 œÜ œà œÜ‚áõœà œ±
  with inspect (‚ü¶ œÜ ‚üß œ±)
... | it tt ‚ü¶œÜ‚üßœ±=tt
  rewrite ‚ü¶œÜ‚üßœ±=tt | œÜ‚áõœà œ± ‚ü¶œÜ‚üßœ±=tt = refl
... | it ff ‚ü¶œÜ‚üßœ±=ff
  rewrite ‚ü¶œÜ‚üßœ±=ff = refl
```

```
entailment-implication-2 : ‚àÄ œÜ œà ‚Üí
  Tautology (œÜ ‚áí œà) ‚Üí
  ------------------
  œÜ ‚áõ œà
 
entailment-implication-2 œÜ œà tau œ± ‚ü¶œÜ‚üßœ±‚â°tt = ‚ü¶œà‚üßœ±‚â°tt where

  have : ‚ü¶ œÜ ‚üß œ± ‚áíùîπ ‚ü¶ œà ‚üß œ± ‚â° tt
  have = tau œ±

  equiv : ‚ü¶ œÜ ‚üß œ± ‚áíùîπ ‚ü¶ œà ‚üß œ± ‚â° ‚ü¶ œà ‚üß œ±
  equiv = ùîπimplProp2 (‚ü¶ œÜ ‚üß œ±) (‚ü¶ œà ‚üß œ±) ‚ü¶œÜ‚üßœ±‚â°tt

  ‚ü¶œà‚üßœ±‚â°tt : ‚ü¶ œà ‚üß œ± ‚â° tt
  ‚ü¶œà‚üßœ±‚â°tt rewrite sym equiv = have
```

We put the two directions together:

```
entailment-implication œÜ œà = entailment-implication-1 œÜ œà , entailment-implication-2 œÜ œà
```

The treatment for equivalence:

```
entailment-equivalence œÜ œà = {!!}
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some equivalences require no computation at all:

```
¬¨¬¨‚ä§‚ü∫‚ä§ : ¬¨ ¬¨ ‚ä§ ‚ü∫ ‚ä§
¬¨¬¨‚ä§‚ü∫‚ä§ œ± = refl
```

More elaborate equivalences require marginally more work,
as shown in the next exercise.

!exercise(#exercise:common-equivalences)(Common equivalences)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the folowing equivalences.
*Hint:* Use the method of truth tables.

```
idempotAnd : ‚àÄ œÜ ‚Üí œÜ ‚àß œÜ ‚ü∫ œÜ

commAnd : ‚àÄ œÜ œà ‚Üí œÜ ‚àß œà ‚ü∫ œà ‚àß œÜ
commOr : ‚àÄ œÜ œà ‚Üí œÜ ‚à® œà ‚ü∫ œà ‚à® œÜ

assocOr : ‚àÄ œÜ œà Œæ ‚Üí (œÜ ‚à® œà) ‚à® Œæ ‚ü∫ œÜ ‚à® œà ‚à® Œæ
assocAnd : ‚àÄ œÜ œà Œæ ‚Üí (œÜ ‚àß œà) ‚àß Œæ ‚ü∫ œÜ ‚àß œà ‚àß Œæ

distrAndOr-left : ‚àÄ œÜ œà Œæ ‚Üí œÜ ‚àß (œà ‚à® Œæ) ‚ü∫ œÜ ‚àß œà ‚à® œÜ ‚àß Œæ
distrAndOr-right : ‚àÄ œÜ œà Œæ ‚Üí (œÜ ‚à® œà) ‚àß Œæ ‚ü∫ œÜ ‚àß Œæ ‚à® œà ‚àß Œæ

expandImplies : ‚àÄ œÜ œà ‚Üí œÜ ‚áí œà ‚ü∫ ¬¨ œÜ ‚à® œà
expandIff : ‚àÄ œÜ œà ‚Üí œÜ ‚áî œà ‚ü∫ (¬¨ œÜ ‚à® œà) ‚àß (œÜ ‚à® ¬¨ œà)

doubleNegationLaw : ‚àÄ œÜ ‚Üí ¬¨ ¬¨ œÜ ‚ü∫ œÜ
deMorganAnd : ‚àÄ œÜ œà ‚Üí ¬¨ (œÜ ‚àß œà) ‚ü∫ ¬¨ œÜ ‚à® ¬¨ œà
deMorganOr : ‚àÄ œÜ œà ‚Üí ¬¨ (œÜ ‚à® œà) ‚ü∫ ¬¨ œÜ ‚àß ¬¨ œà
deMorganOr-alt : ‚àÄ œÜ œà ‚Üí œÜ ‚à® œà ‚ü∫ ¬¨ (¬¨ œÜ ‚àß ¬¨ œà)
deMorganImplies : ‚àÄ œÜ œà ‚Üí ¬¨ (œÜ ‚áí œà) ‚ü∫ œÜ ‚àß ¬¨ œà
deMorganIff-left : ‚àÄ œÜ œà ‚Üí ¬¨ (œÜ ‚áî œà) ‚ü∫ ¬¨ œÜ ‚áî œà
deMorganIff-right : ‚àÄ œÜ œà ‚Üí ¬¨ (œÜ ‚áî œà) ‚ü∫ œÜ ‚áî ¬¨ œà
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
idempotAnd œÜ œ± = idempot-‚àßùîπ (‚ü¶ œÜ ‚üß œ±)

commAnd œÜ œà œ± = comm-‚àßùîπ (‚ü¶ œÜ ‚üß œ±) (‚ü¶ œà ‚üß œ±)
commOr œÜ œà œ± = comm-‚à®ùîπ (‚ü¶ œÜ ‚üß œ±) (‚ü¶ œà ‚üß œ±)

assocOr œÜ œà Œæ œ± = assoc-‚à®ùîπ (‚ü¶ œÜ ‚üß œ±) (‚ü¶ œà ‚üß œ±) (‚ü¶ Œæ ‚üß œ±)
assocAnd œÜ œà Œæ œ± = assoc-‚àßùîπ (‚ü¶ œÜ ‚üß œ±) (‚ü¶ œà ‚üß œ±) (‚ü¶ Œæ ‚üß œ±)
distrAndOr-left œÜ œà Œæ œ± = distr-left-‚àß‚à®ùîπ (‚ü¶ œÜ ‚üß œ±) (‚ü¶ œà ‚üß œ±) (‚ü¶ Œæ ‚üß œ±)
distrAndOr-right œÜ œà Œæ œ± = distr-right-‚àß‚à®ùîπ (‚ü¶ œÜ ‚üß œ±) (‚ü¶ œà ‚üß œ±) (‚ü¶ Œæ ‚üß œ±)

expandImplies œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

expandIff œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

doubleNegationLaw œÜ œ± with ‚ü¶ œÜ ‚üß œ±
... | tt = refl
... | ff = refl

deMorganAnd œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

deMorganOr œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

deMorganOr-alt œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

deMorganImplies œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

deMorganIff-left œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

deMorganIff-right œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Equivalence is a congruence

Logical equivalence is a *congruence*,
in the sense that replacing a formula with an equivalent one preserves the semantics:

```
congF : ‚àÄ œÜ œà Œæ p ‚Üí
  œÜ ‚ü∫ œà ‚Üí
  -----------------------------
  Œæ F[ p ‚Ü¶ œÜ ] ‚ü∫ Œæ F[ p ‚Ü¶ œà ]
```

!hide
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The proof follows a straightforward structural induction.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
congF _ _ ‚ä§ p œÜ‚ü∫œà œ± = refl

congF _ _ ‚ä• p œÜ‚ü∫œà œ± = refl

congF _ _ (` q) p œÜ‚ü∫œà œ±
  with p ‚â°? q
... | yes _ = œÜ‚ü∫œà œ±
... | no _ = refl

congF œÜ œà (¬¨ Œæ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ p œÜ‚ü∫œà œ±
... | ind rewrite ind = refl

congF œÜ œà (Œæ‚ÇÄ ‚àß Œæ‚ÇÅ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ‚ÇÄ p œÜ‚ü∫œà œ± |
       congF œÜ œà Œæ‚ÇÅ p œÜ‚ü∫œà œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

congF œÜ œà (Œæ‚ÇÄ ‚à® Œæ‚ÇÅ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ‚ÇÄ p œÜ‚ü∫œà œ± |
       congF œÜ œà Œæ‚ÇÅ p œÜ‚ü∫œà œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

congF œÜ œà (Œæ‚ÇÄ ‚áí Œæ‚ÇÅ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ‚ÇÄ p œÜ‚ü∫œà œ± |
       congF œÜ œà Œæ‚ÇÅ p œÜ‚ü∫œà œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

congF œÜ œà (Œæ‚ÇÄ ‚áî Œæ‚ÇÅ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ‚ÇÄ p œÜ‚ü∫œà œ± |
       congF œÜ œà Œæ‚ÇÅ p œÜ‚ü∫œà œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:cong2F)
~~~~~~~~~~~~~~~~~~~~~~~~~~

Show that replacing *two* formulas with two equivalent ones in parallel respects the semantics:

```
cong2F : ‚àÄ œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ p‚ÇÄ p‚ÇÅ ‚Üí
  œÜ‚ÇÄ ‚ü∫ œà‚ÇÄ ‚Üí
  œÜ‚ÇÅ ‚ü∫ œà‚ÇÅ ‚Üí
  -----------------------------------------------------
  Œæ F2[ p‚ÇÄ , p‚ÇÅ ‚Ü¶ œÜ‚ÇÄ , œÜ‚ÇÅ ] ‚ü∫ Œæ F2[ p‚ÇÄ , p‚ÇÅ ‚Ü¶ œà‚ÇÄ , œà‚ÇÅ ]
```
~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~
```
cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ ‚ä• p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ ‚ä§ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (` p) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with p‚ÇÄ ‚â°? p
... | yes _ = œÜ‚ÇÄ‚ü∫œà‚ÇÄ œ±
... | no _
  with p‚ÇÅ ‚â°? p
... | yes _ = œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | no _ = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (¬¨ Œæ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind rewrite ind = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (Œæ‚ÇÄ ‚àß Œæ‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÄ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± |
       cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÅ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (Œæ‚ÇÄ ‚à® Œæ‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÄ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± |
       cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÅ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (Œæ‚ÇÄ ‚áí Œæ‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÄ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± |
       cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÅ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (Œæ‚ÇÄ ‚áî Œæ‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÄ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± |
       cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÅ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~

The congruence properties !ref(congF) and !ref(cong2F) are very convenient to quickly show correctness of many formula transformations
(such as those in [Functional completeness](#Functional-Completeness) below and in transformations to [normal forms](../../part1/NormalForms).

## Satisfiability

A formula `œÜ` is *satisfiable* if there exists some valuation satisfying it:

```
Sat : Formula ‚Üí Set
Sat œÜ = ‚àÉ[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â° tt
```

Satisfiability is decidable (for every fixed number of propositional variables)
since we can enumerate satisfying assignments:

```
Sat? : ‚àÄ œÜ ‚Üí Dec (Sat œÜ)
Sat? œÜ = ‚àÉ?[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â°? tt
```

For instance, the formula `` ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ `` is satisfiable,
however `` ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÄ `` is not:

```
_ : n ‚â° 3 ‚Üí ‚åû Sat? (` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ) ‚åü ‚â° tt
_ = Œª{refl ‚Üí refl}

_ : n ‚â° 3 ‚Üí ‚åû Sat? (` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÄ) ‚åü ‚â° ff
_ = Œª{refl ‚Üí refl}
```

Of course we can also prove that the latter formula is unsatisfiable for *every* number of variables:

```
p‚àß¬¨p-unsat : ~ Sat (` p ‚àß ¬¨ ` p)
p‚àß¬¨p-unsat {p} (œ± , equiv) with œ± p
... | tt = ff‚â¢tt equiv
... | ff = ff‚â¢tt equiv
```

!exercise(#exercise:tau-sat)(Tautology and satisfiability)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Elaborate and prove a natural property connecting whether `œÜ` is a tautology and satisfiability.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
One possible property is the following:

```
tau-sat : ‚àÄ œÜ ‚Üí Tautology œÜ ‚Üî ~ Sat (¬¨ œÜ)
tau-sat œÜ = tau‚Üísat , sat‚Üítau where

  tau‚Üísat : Tautology œÜ ‚Üí ~ Sat (¬¨ œÜ)
  tau‚Üísat tauœÜ (œ± , ‚ü¶¬¨œÜ‚üßœ±‚â°tt)
    with inspect (‚ü¶ œÜ ‚üß œ±)
  ... | it tt ‚ü¶œÜ‚üßœ±‚â°tt rewrite ‚ü¶œÜ‚üßœ±‚â°tt = ff‚â¢tt ‚ü¶¬¨œÜ‚üßœ±‚â°tt
  ... | it ff ‚ü¶œÜ‚üßœ±‚â°ff = ff‚â¢tt (trans (sym ‚ü¶œÜ‚üßœ±‚â°ff) (tauœÜ œ±))
  
  sat‚Üítau : ~ Sat (¬¨ œÜ) ‚Üí Tautology œÜ
  sat‚Üítau ~Sat¬¨œÜ œ±
    with inspect (‚ü¶ œÜ ‚üß œ±)
  ... | it tt ‚ü¶œÜ‚üßœ±‚â°tt = ‚ü¶œÜ‚üßœ±‚â°tt
  ... | it ff ‚ü¶œÜ‚üßœ±‚â°ff = F-elim (~Sat¬¨œÜ (œ± , ¬¨ùîπ‚ü¶œÜ‚üßœ±‚â°tt)) where

    ¬¨ùîπ‚ü¶œÜ‚üßœ±‚â°tt : ¬¨ùîπ ‚ü¶ œÜ ‚üß œ± ‚â° tt
    ¬¨ùîπ‚ü¶œÜ‚üßœ±‚â°tt rewrite ‚ü¶œÜ‚üßœ±‚â°ff = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:equiv-unsat)(Equivalence and unsatisfiability)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Express unsatisfiability in terms of logical equivalence.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
One possible property is that a formula is unsatisfiable if, and only if, it is logically equivalent to !ref(‚ä•):

```
equiv‚Üîunsat : œÜ ‚ü∫ ‚ä• ‚Üî ~ Sat œÜ
```

We prove the two directions separately:

```
equiv‚Üíunsat : œÜ ‚ü∫ ‚ä• ‚Üí ~ Sat œÜ
equiv‚Üíunsat œÜ‚ü∫‚ä• (œ± , ‚ü¶œÜ‚üßœ±‚â°tt)
  with œÜ‚ü∫‚ä• œ±
... | ‚ü¶œÜ‚üßœ±‚â°ff = a‚â°ff‚Üía‚â°tt-elim ‚ü¶œÜ‚üßœ±‚â°ff ‚ü¶œÜ‚üßœ±‚â°tt
```

```
unsat‚Üíequiv : ~ Sat œÜ ‚Üí œÜ ‚ü∫ ‚ä•
unsat‚Üíequiv {œÜ} ~SatœÜ œ±
  with inspect (‚ü¶ œÜ ‚üß œ±)
... | it ff ‚ü¶œÜ‚üßœ±‚â°ff = ‚ü¶œÜ‚üßœ±‚â°ff
... | it tt ‚ü¶œÜ‚üßœ±‚â°tt = F-elim (~SatœÜ (œ± , ‚ü¶œÜ‚üßœ±‚â°tt))
```

It is now just a matter of combining the two directions:

```
equiv‚Üîunsat {œÜ} = equiv‚Üíunsat {œÜ} , unsat‚Üíequiv {œÜ}
```

For instance, we can prove:

```
p‚àß¬¨p‚ü∫‚ä• : ` p ‚àß ¬¨ ` p ‚ü∫ ‚ä•
p‚àß¬¨p‚ü∫‚ä• {p} œ± = unsat‚Üíequiv {` p ‚àß ¬¨ ` p} p‚àß¬¨p-unsat œ±
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Long conjunctions and disjunctions

### Conjunctions

Sometimes it is useful to interpret a list of formulas as their conjunction.
This is achieved with the following "long conjunction" operation:

```
infix 10 ‚ãÄ_
‚ãÄ_ : Formula * ‚Üí Formula
‚ãÄ œÜs = foldr1 _‚àß_ ‚ä§ œÜs
```

(Despite the typographical similarity,
!ref(‚ãÄ_) is a unary function mapping lists of formulas to their logical conjunction,
while [`_‚àß_ : Formula ‚Üí Formula ‚Üí Formula`](#Formula._‚àß_) is a binary formula constructor.)
For instance, we have

```
_ : ‚ãÄ [ (` p‚ÇÄ) (` p‚ÇÅ) (` p‚ÇÇ) ] ‚â° ` p‚ÇÄ ‚àß ` p‚ÇÅ ‚àß ` p‚ÇÇ
_ = refl
```

The following are the two defining properties of long conjunctions:

```
conjProp1 : ‚àÄ œÜs œ± ‚Üí
  ‚ü¶ ‚ãÄ œÜs ‚üß œ± ‚â° tt ‚Üí
  ------------------------
  ‚àÄ[ œÜ ‚àà œÜs ] ‚ü¶ œÜ ‚üß œ± ‚â° tt

conjProp2 : ‚àÄ œÜs œ± ‚Üí
  ‚àÄ[ œÜ ‚àà œÜs ] ‚ü¶ œÜ ‚üß œ± ‚â° tt ‚Üí
  ---------------
  ‚ü¶ ‚ãÄ œÜs ‚üß œ± ‚â° tt
```

!exercise(#exercise:long-conjunctions)(Long conjunctions)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the two defining properties !ref(conjProp1) and !ref(conjProp2) of long conjunctions
*Hint:* Use the corresponding properties for Booleans.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
conjProp1 (œà ‚à∑ Œµ) œ± ‚ü¶œÜs‚üß‚â°tt here = ùîπconjProp1 (‚ü¶ œà ‚üß œ±) tt ‚ü¶œÜs‚üß‚â°tt
conjProp1 (œà ‚à∑ œÜs@(_ ‚à∑ _)) œ± ‚ü¶œÜs‚üß‚â°tt here = ùîπconjProp1 (‚ü¶ œà ‚üß œ±) (‚ü¶ ‚ãÄ œÜs ‚üß œ±) ‚ü¶œÜs‚üß‚â°tt 
conjProp1 (œà ‚à∑ œÜs@(_ ‚à∑ _)) œ± ‚ü¶œà‚àßœÜs‚üß‚â°tt {œÜ} (there œÜ‚ààœÜs)
  = conjProp1 œÜs œ± (ùîπconjProp2 (‚ü¶ œà ‚üß œ±) _ ‚ü¶œà‚àßœÜs‚üß‚â°tt) œÜ‚ààœÜs 

conjProp2 Œµ œ± ass = refl
conjProp2 (œÜ ‚à∑ Œµ) œ± ass = ass here
conjProp2 (œÜ ‚à∑ œÜs@(_ ‚à∑ _)) œ± ass
  with conjProp2 œÜs œ± Œª œà‚ààœÜs ‚Üí ass (there œà‚ààœÜs)
... | ‚ü¶‚ãÄœÜs‚üßœ±‚â°tt = ùîπconjProp3 _ _ ‚ü¶œÜ‚üßœ±‚â°tt ‚ü¶‚ãÄœÜs‚üßœ±‚â°tt where

  ‚ü¶œÜ‚üßœ±‚â°tt : ‚ü¶ œÜ ‚üß œ± ‚â° tt
  ‚ü¶œÜ‚üßœ±‚â°tt = ass here
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Disjunctions

We can also take "long disjunctions" of a sequence of formulas.
The corresponding two defining properties are dual to those of long conjunctions.

```
infix 9 ‚ãÅ_
‚ãÅ_ : Formula * ‚Üí Formula
‚ãÅ œÜs = foldr _‚à®_ ‚ä• œÜs

disjProp-tt : ‚àÄ œÜs œ± œÜ ‚Üí
  œÜ ‚àà œÜs ‚Üí
  ‚ü¶ œÜ ‚üß œ± ‚â° tt ‚Üí
  ---------------
  ‚ü¶ ‚ãÅ œÜs ‚üß œ± ‚â° tt

disjProp-ff : ‚àÄ œÜs œ± ‚Üí
  ‚àÄ[ œÜ ‚àà œÜs ] ‚ü¶ œÜ ‚üß œ± ‚â° ff ‚Üí
  ---------------
  ‚ü¶ ‚ãÅ œÜs ‚üß œ± ‚â° ff
```

!exercise(#exercise:long-disjunctions)(Long disjunctions) 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the two defining properties !ref(disjProp-tt) and !ref(disjProp-ff) above.
*Hint:* Use the corresponding properties for Booleans.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
disjProp-tt (œÜ ‚à∑ _) œ± œÜ here ‚ü¶œÜ‚üßœ±‚â°tt rewrite ‚ü¶œÜ‚üßœ±‚â°tt = refl
disjProp-tt (œà ‚à∑ _) œ± œÜ (there œÜ‚ààœÜs) ‚ü¶œÜ‚üßœ±‚â°tt
  with disjProp-tt _ œ± œÜ œÜ‚ààœÜs ‚ü¶œÜ‚üßœ±‚â°tt
... | ind = ùîπdisjProp2 (‚ü¶ œà ‚üß œ±) _ ind

disjProp-ff Œµ œ± ass = refl
disjProp-ff (œÜ ‚à∑ œÜs) œ± ass
  with disjProp-ff œÜs œ± Œª œà‚ààœÜs ‚Üí ass (there œà‚ààœÜs)
... | ind = ùîπdisjProp3 _ _ (ass here) ind
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Semantic deduction theorem

### Contexts

A *context* is a list of formulas.
The empty context will be denoted by `‚àÖ`.

```
Context = Formula *

‚àÖ : Context
‚àÖ = Œµ

private
  variable
    Œì Œî : Context
```

If `Œì` is a context and `œÜ` is a formula,
then we can add `œÜ` to `Œì` and form the new context `Œì ¬∑ œÜ`
(this is just adding an element in front of a list but written on the right).

```
infixl 50 _¬∑_  
_¬∑_ : Context ‚Üí Formula ‚Üí Context
Œì ¬∑ œÜ = œÜ ‚à∑ Œì
```

We say that a context `Œì` *entails* (or *logically implies*) a formula `œà`
if every valuation that satisfies every formula in `Œì`
satisfies `œà` as well:

```
infix 9 _‚ä®_
_‚ä®_ : Context ‚Üí Formula ‚Üí Set
Œì ‚ä® œà = ‚àÄ œ± ‚Üí All (Œª œÜ ‚Üí ‚ü¶ œÜ ‚üß œ± ‚â° tt) Œì ‚Üí ‚ü¶ œà ‚üß œ± ‚â° tt
```

!exercise(#exercise:commutative-context)(Commutativity of context)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Show that the order of the formulas in the context does not matter w.r.t. the satisfaction relation:

```
perm-sat : ‚àÄ {Œì Œî œ±} ‚Üí
  Perm Œì Œî ‚Üí
  All (Œª œÜ ‚Üí ‚ü¶ œÜ ‚üß œ± ‚â° tt) Œì ‚Üí
  --------------------------
  All (Œª œÜ ‚Üí ‚ü¶ œÜ ‚üß œ± ‚â° tt) Œî
```

*Hint*: Proceed by structural induction on permutations.
Deduce that the logical consequence relation is invariant under context permutation:

```
perm-‚ä® : ‚àÄ {Œì Œî} œÜ ‚Üí
  Perm Œì Œî ‚Üí
  Œì ‚ä® œÜ ‚Üí
  -----
  Œî ‚ä® œÜ
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
perm-sat stop AllŒì {œÜ} œÜ‚ààŒî = AllŒì œÜ‚ààŒî

perm-sat {œà ‚à∑ Œì} {œà ‚à∑ Œî} (skip perm) AllŒì {œà} here = AllŒì here
perm-sat {œà ‚à∑ Œì} {œà ‚à∑ Œî} (skip perm) AllŒì {œÜ} (there œÜ‚ààŒî)
  = perm-sat {Œì} {Œî} perm (Œª {Œæ} Œæ‚ààŒì ‚Üí AllŒì (there Œæ‚ààŒì)) œÜ‚ààŒî
  
perm-sat (swap perm) AllŒì {_} here = AllŒì (there here)
perm-sat (swap perm) AllŒì {_} (there here) = AllŒì here
perm-sat {œÜ ‚à∑ œà ‚à∑ Œì} {œà ‚à∑ œÜ ‚à∑ Œî} (swap perm) AllŒì {Œæ} (there (there Œæ‚ààŒî))
  = perm-sat perm (AllŒì ‚àò there ‚àò there) Œæ‚ààŒî 

perm-sat {Œì} {Œî} (tran {bs = Œû} perm1 perm2) AllŒì
  with perm-sat perm1 AllŒì
... | AllŒû = perm-sat perm2 AllŒû
                            
perm-‚ä® œÜ perm Œì‚ä®œÜ œ± AllŒî = Œì‚ä®œÜ œ± (perm-sat (perm-sym perm) AllŒî)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:context-alt)(Alternative definition of entailment)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
An alternative definition of entailment `Œì ‚ä® œÜ` between a context and a formula
could be based on the previous definition of entailment `œà ‚áõ œÜ` between two formulas:

```
_‚ä®‚Ä≤_ : Context ‚Üí Formula ‚Üí Set
Œì ‚ä®‚Ä≤ œÜ = ‚ãÄ Œì ‚áõ œÜ
```

Show that the two notions of entailment are equivalent:

```
context1 : ‚àÄ {Œì} œÜ ‚Üí
  Œì ‚ä® œÜ ‚Üí
  ------
  Œì ‚ä®‚Ä≤ œÜ
  
context2 : ‚àÄ Œì {œÜ} ‚Üí
  Œì ‚ä®‚Ä≤ œÜ ‚Üí
  -----
  Œì ‚ä® œÜ
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
context1 {Œì} œÜ Œì‚ä®œÜ œ± ‚ü¶‚ãÄŒì‚üßœ±‚â°tt = Œì‚ä®œÜ œ± (conjProp1 Œì œ± ‚ü¶‚ãÄŒì‚üßœ±‚â°tt)
context2 Œì {œÜ} ‚ãÄŒì‚áõœÜ œ± AllŒì = ‚ãÄŒì‚áõœÜ œ± (conjProp2 Œì œ± AllŒì)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Deduction theorem

The semantic deduction theorem establishes a close connection between the implication connective !ref(Formula)(_‚áí_),
which is a syntactic object,
and entailment !ref(_‚ä®_), which is a semantic one.
It consists of two halves.
The first half shows how to move a formula from the formula to the context:

```
semDT1 : ‚àÄ œÜ œà ‚Üí
  Œì ‚ä® œÜ ‚áí œà ‚Üí
  ---------
  Œì ¬∑ œÜ ‚ä® œà
```

The second half shows the converse operation:

```
semDT2 : ‚àÄ œÜ œà ‚Üí
  Œì ¬∑ œÜ ‚ä® œà ‚Üí
  ----------
  Œì ‚ä® œÜ ‚áí œà
```

!exercise(#exercise:sem-DT)(Semantic deduction theorem)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the two parts !ref(semDT2) and !ref(semDT1) of the semantic deduction theorem.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
semDT2 {Œì} œà œÜ Œì¬∑œà‚ä®œÜ = Œî‚ä®œà‚áíœÜ where

  Œî‚ä®œà‚áíœÜ : Œì ‚ä® œà ‚áí œÜ
  Œî‚ä®œà‚áíœÜ œ± ‚ü¶Œì‚üß with inspect (‚ü¶ œà ‚üß œ±)
  ... | it ff ‚ü¶œà‚üßœ±‚â°ff rewrite ‚ü¶œà‚üßœ±‚â°ff = refl
  ... | it tt ‚ü¶œà‚üßœ±‚â°tt rewrite ‚ü¶œà‚üßœ±‚â°tt = trans eql ‚ü¶œÜ‚üßœ±‚â°tt where

    eql : tt ‚áíùîπ ‚ü¶ œÜ ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ±
    eql = ùîπimplProp2 _ _ refl
    
    ‚ü¶œÜ‚üßœ±‚â°tt : ‚ü¶ œÜ ‚üß œ± ‚â° tt
    ‚ü¶œÜ‚üßœ±‚â°tt = Œì¬∑œà‚ä®œÜ œ± ‚ü¶œà‚à∑Œì‚üß where

      ‚ü¶œà‚à∑Œì‚üß : ‚àÄ[ Œæ ‚àà œà ‚à∑ Œì ] ‚ü¶ Œæ ‚üß œ± ‚â° tt
      ‚ü¶œà‚à∑Œì‚üß here = ‚ü¶œà‚üßœ±‚â°tt
      ‚ü¶œà‚à∑Œì‚üß (there Œæ‚ààŒì) = ‚ü¶Œì‚üß Œæ‚ààŒì

semDT1 {Œì} œÜ œà Œì‚ä®œÜ‚áíœà œ± AllŒì¬∑œÜ = ‚ü¶œà‚üßœ±‚â°tt where

  AllŒì : All (Œª œÜ ‚Üí ‚ü¶ œÜ ‚üß œ± ‚â° tt) Œì
  AllŒì {œÜ} œÜ‚ààŒì = AllŒì¬∑œÜ (there œÜ‚ààŒì)

  ‚ü¶œÜ‚üßœ±‚â°tt : ‚ü¶ œÜ ‚üß œ± ‚â° tt
  ‚ü¶œÜ‚üßœ±‚â°tt = AllŒì¬∑œÜ here
  
  ‚ü¶œà‚üßœ±‚â°tt : ‚ü¶ œà ‚üß œ± ‚â° tt
  ‚ü¶œà‚üßœ±‚â°tt rewrite sym (ùîπimplProp2 _ (‚ü¶ œà ‚üß œ±) ‚ü¶œÜ‚üßœ±‚â°tt) = Œì‚ä®œÜ‚áíœà œ± AllŒì 
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By repeated application of the semantic deduction theorem,
we can in fact move all formulas from one side to the other.
First, we define "long implications":

```
infix 10 _Imply_
_Imply_ : Formula * ‚Üí Formula ‚Üí Formula
Œµ Imply œÜ = œÜ
(œà ‚à∑ Œî) Imply œÜ = Œî Imply (œà ‚áí œÜ)
```

For instance,

```
_ : ‚àÖ ¬∑ œÜ‚ÇÄ ¬∑ œÜ‚ÇÅ Imply ` p‚ÇÄ ‚â° œÜ‚ÇÄ ‚áí œÜ‚ÇÅ ‚áí ` p‚ÇÄ
_ = refl
```

TODO: put it in context as an application of DT

```
modus-ponens : ‚àÄ {Œì} œÜ œà ‚Üí
  Œì ‚ä® œÜ ‚áí œà ‚Üí
  Œì ‚ä® œÜ ‚Üí
  ------
  Œì ‚ä® œà

modus-ponens œÜ œà Œì‚ä®œÜ‚áíœà Œì‚ä®œÜ œ± x
 with semDT1 œÜ œà Œì‚ä®œÜ‚áíœà
... | Œì¬∑œÜ‚ä®œà = Œì¬∑œÜ‚ä®œà œ± Œª{ here ‚Üí Œì‚ä®œÜ œ± x
                        ; (there y) ‚Üí x y}
```

We can now state the following "long" versions of the semantic deduction theorem.

```
longSemDT1 :
  Œî ‚ä® œÜ ‚Üí
  -------------
  ‚àÖ ‚ä® Œî Imply œÜ

longSemDT2 :
  ‚àÖ ‚ä® Œî Imply œÜ ‚Üí
  -----
  Œî ‚ä® œÜ
```

!hide
~~~~~~~~~
The proofs are a straightforward applications of !ref(semDT2) and !ref(semDT1).
~~~~~~~~~
~~~~~~~~~
```
longSemDT1 {Œµ} {œÜ} Œµ‚ä®œÜ = Œµ‚ä®œÜ
longSemDT1 {œà ‚à∑ Œî} {œÜ} œà‚à∑Œî‚ä®œÜ = longSemDT1 {Œî} {œà ‚áí œÜ} (semDT2 œà œÜ œà‚à∑Œî‚ä®œÜ)

longSemDT2 {Œµ} {œÜ} ‚àÖ‚ä®œÜ œ± All‚àÖ = ‚àÖ‚ä®œÜ œ± All‚àÖ
longSemDT2 {œà ‚à∑ Œî} {œÜ} ‚àÖ‚ä®ŒîImplyœÜ = semDT1 œà œÜ (longSemDT2 {Œî} {œà ‚áí œÜ} ‚àÖ‚ä®ŒîImplyœÜ)
```
~~~~~~~~~

# Formula simplification

In this section we present a procedure to simplify formulas.
We start with a simple use case to illustrate some practical difficulties that naturally arise.
Suppose we want to remove a single outmost double negation `¬¨ ¬¨ œÜ` in a formula.
A natural definition would be the following:

```
remove-¬¨¬¨1 : Formula ‚Üí Formula
remove-¬¨¬¨1 (¬¨ ¬¨ œÜ) = œÜ
remove-¬¨¬¨1 œÜ = œÜ
```

The next step is to prove that the definition above is correct:

```
remove-¬¨¬¨1-correctness : ‚àÄ œÜ ‚Üí œÜ ‚ü∫ remove-¬¨¬¨1 œÜ
```

Due to the nature of pattern matching in Agda,
the following does not work as expected:

    remove-¬¨¬¨1-correctness (¬¨ ¬¨ œÜ) œ± = refl
    remove-¬¨¬¨1-correctness œÜ œ± = refl

The interpreter is not able to expand `remove-¬¨¬¨1 œÜ` into `œÜ` in the second clause.
In order to trigger evaluation, we need to convince the interpreter that `œÜ` is not of the form `¬¨ ¬¨ œà`,
requiring us to list many more cases that we may like to:

!hide
~~~~~~
```
remove-¬¨¬¨1-correctness (¬¨ ¬¨ œÜ) œ± = refl
remove-¬¨¬¨1-correctness ‚ä• œ± = refl
remove-¬¨¬¨1-correctness ‚ä§ œ± = refl
{- ... and many more ... -}
```
~~~~~~
~~~~~~
```
remove-¬¨¬¨1-correctness (` p) œ± = refl
remove-¬¨¬¨1-correctness (¬¨ ‚ä•) œ± = refl
remove-¬¨¬¨1-correctness (¬¨ ‚ä§) œ± = refl
remove-¬¨¬¨1-correctness (¬¨ ` p) œ± = refl
remove-¬¨¬¨1-correctness (¬¨ (œÜ ‚à® œà)) œ± = refl
remove-¬¨¬¨1-correctness (¬¨ (œÜ ‚àß œà)) œ± = refl
remove-¬¨¬¨1-correctness (¬¨ (œÜ ‚áí œà)) œ± = refl
remove-¬¨¬¨1-correctness (¬¨ (œÜ ‚áî œà)) œ± = refl
remove-¬¨¬¨1-correctness (œÜ ‚à® œà) œ± = refl
remove-¬¨¬¨1-correctness (œÜ ‚àß œà) œ± = refl
remove-¬¨¬¨1-correctness (œÜ ‚áí œà) œ± = refl
remove-¬¨¬¨1-correctness (œÜ ‚áî œà) œ± = refl
```
~~~~~~

## Views

The standard solution in a case like this is to use *views* [@Wadler:POPL:1987;@McBrideMcKinna:JFL:2004].

An inductive definition such as !ref(Formula) provides what we may call the "default view",
i.e., whether a formula is !ref(Formula)(‚ä•), !ref(Formula)(‚ä§), and so on.
A definition by structural recursion on !ref(Formula) such as !ref(‚ü¶_‚üß_) is using this default view.

When the default view is not adequate, we can define alternative views (presentations) of the same data.
In our use case, the view should reflect the recursive structure of !ref(remove-¬¨¬¨1).
We may thus say that a view is a means to encode recursion into data.
In our example, we will have two constructors,
depending on whether the formula is a double negation or not:

```
data Remove-¬¨¬¨-View : Formula ‚Üí Set where
  go-¬¨¬¨ : ‚àÄ œà ‚Üí Remove-¬¨¬¨-View (¬¨ ¬¨ œà)
  stop : ‚àÄ œà ‚Üí Remove-¬¨¬¨-View œà
```

A view for formulas has the general type `Formula ‚Üí Set`,
and can thus be thought of as a property of formulas.
The peculiar things about views is that every formula will have a view for it
(after all we are encoding total functions).
The following unsurprising function computes the view corresponding to the input formula:

```
remove-¬¨¬¨-View : ‚àÄ œÜ ‚Üí Remove-¬¨¬¨-View œÜ
remove-¬¨¬¨-View (¬¨ ¬¨ œÜ) = go-¬¨¬¨ œÜ
remove-¬¨¬¨-View œÜ = stop œÜ
```

The function !ref(remove-¬¨¬¨-View) is as simple as it gets.
In particular, we can use the catch-all pattern in the second case to already decide that the output will be `stop œÜ`.
Once we have a way of computing the view of interest,
we can use it to encode !ref(remove-¬¨¬¨) and its correctness proof !ref(remove-¬¨¬¨-correctness):

```
remove-¬¨¬¨ : Formula ‚Üí Formula
remove-¬¨¬¨ œÜ with remove-¬¨¬¨-View œÜ
... | go-¬¨¬¨ œà = œà
... | stop œà = œà
```

```
remove-¬¨¬¨-correctness : ‚àÄ œÜ ‚Üí œÜ ‚ü∫ remove-¬¨¬¨ œÜ
remove-¬¨¬¨-correctness œÜ œ± with remove-¬¨¬¨-View œÜ
... | go-¬¨¬¨ œà = refl
... | stop œà = refl
```

It is instructive to compare !ref(remove-¬¨¬¨-correctness) with !ref(remove-¬¨¬¨1-correctness) w.r.t. size.

Views may look a little roundabout at first.
One may wonder whether the following simpler datatype may work too:

```
data Remove-¬¨¬¨-View‚Ä≤ : Set where
  go-¬¨¬¨‚Ä≤ : Remove-¬¨¬¨-View‚Ä≤
  stop‚Ä≤ : Remove-¬¨¬¨-View‚Ä≤

remove-¬¨¬¨-View‚Ä≤ : Formula ‚Üí Remove-¬¨¬¨-View‚Ä≤
remove-¬¨¬¨-View‚Ä≤ (¬¨ ¬¨ œÜ) = go-¬¨¬¨‚Ä≤
remove-¬¨¬¨-View‚Ä≤ œÜ = stop‚Ä≤
```

However, the simpler !ref(Remove-¬¨¬¨-View‚Ä≤) is insufficient
since we lose track of the connection between the view and the formula it is a view of.
For instance, we immediately run into trouble when defining `remove-¬¨¬¨‚Ä≤`:

    remove-¬¨¬¨‚Ä≤ : Formula ‚Üí Formula
    remove-¬¨¬¨‚Ä≤ œÜ with remove-¬¨¬¨-View‚Ä≤ œÜ
    remove-¬¨¬¨‚Ä≤ (¬¨ ¬¨ œà) | go-¬¨¬¨‚Ä≤ = œà
    remove-¬¨¬¨‚Ä≤ œÜ | stop‚Ä≤ = œÜ

The interpreter complains that there are missing cases,
such as `remove-¬¨¬¨‚Ä≤ ‚ä• | go-¬¨¬¨‚Ä≤`, `remove-¬¨¬¨‚Ä≤ ‚ä§ | go-¬¨¬¨‚Ä≤`, and so on.
The additional power of views is that the interpeter knows from the constructor to which formula does the view correspond,
and thus it is able to figure out that the definition in !ref(remove-¬¨¬¨) is complete.

## Full fledged simplification

After this introduction on views,
we can present a more powerful simplification procedure.
Our aim is to

- remove the constants !ref(Formula)(‚ä•) and !ref(Formula)(‚ä§) (unless this is all what the formula is), and
- remove double negations `¬¨ ¬¨ œÜ`.

To this end, we define the following view:

```
data SimplifyView : Formula ‚Üí Set where

  ¬¨‚ä• : SimplifyView (¬¨ ‚ä•)
  ¬¨‚ä§ : SimplifyView (¬¨ ‚ä§)
  ¬¨¬¨_ : ‚àÄ œà ‚Üí SimplifyView (¬¨ ¬¨ œà)

  ‚ä•‚à®_ : ‚àÄ œà ‚Üí SimplifyView (‚ä• ‚à® œà)
  _‚à®‚ä• : ‚àÄ œà ‚Üí SimplifyView (œà ‚à® ‚ä•)
  ‚ä§‚à®_ : ‚àÄ œà ‚Üí SimplifyView (‚ä§ ‚à® œà)
  _‚à®‚ä§ : ‚àÄ œà ‚Üí SimplifyView (œà ‚à® ‚ä§)
  
  ‚ä•‚àß_ : ‚àÄ œà ‚Üí SimplifyView (‚ä• ‚àß œà)
  _‚àß‚ä• : ‚àÄ œà ‚Üí SimplifyView (œà ‚àß ‚ä•)
  ‚ä§‚àß_ : ‚àÄ œà ‚Üí SimplifyView (‚ä§ ‚àß œà)
  _‚àß‚ä§ : ‚àÄ œà ‚Üí SimplifyView (œà ‚àß ‚ä§)
  
  ‚ä•‚áí_ : ‚àÄ œà ‚Üí SimplifyView (‚ä• ‚áí œà)
  _‚áí‚ä• : ‚àÄ œà ‚Üí SimplifyView (œà ‚áí ‚ä•)
  ‚ä§‚áí_ : ‚àÄ œà ‚Üí SimplifyView (‚ä§ ‚áí œà)
  _‚áí‚ä§ : ‚àÄ œà ‚Üí SimplifyView (œà ‚áí ‚ä§)
  
  ‚ä•‚áî_ : ‚àÄ œà ‚Üí SimplifyView (‚ä• ‚áî œà)
  _‚áî‚ä• : ‚àÄ œà ‚Üí SimplifyView (œà ‚áî ‚ä•)
  ‚ä§‚áî_ : ‚àÄ œà ‚Üí SimplifyView (‚ä§ ‚áî œà)
  _‚áî‚ä§ : ‚àÄ œà ‚Üí SimplifyView (œà ‚áî ‚ä§)
  
  stop : ‚àÄ œà ‚Üí SimplifyView œà  
```

We have one constructor for each kind of subformula that we want to reduce.
The view `‚ä•‚à® œà` is designed to look typographically similar to the underlying formula `‚ä• ‚à® œà` for suggestive purposes,
and similarly for the others.
However, it is important to keep in mind that the latter is of type !ref(Formula),
while the former is of type `SimplifyView (‚ä• ‚à® œà)`.
The last constructor `stop œÜ` signals that no further simplification is available.
The following function computes the view:

```
simplifyView : ‚àÄ œÜ ‚Üí SimplifyView œÜ
```

!hide
~~~~~~~~
Its definition is unimaginative.
~~~~~~~~
~~~~~~~~
```
simplifyView (¬¨ ‚ä•) = ¬¨‚ä•
simplifyView (¬¨ ‚ä§) = ¬¨‚ä§
simplifyView (¬¨ ¬¨ œÜ) = ¬¨¬¨ œÜ

simplifyView (‚ä• ‚à® œÜ) = ‚ä•‚à® œÜ
simplifyView (œÜ ‚à® ‚ä•) = œÜ ‚à®‚ä•
simplifyView (‚ä§ ‚à® œÜ) = ‚ä§‚à® œÜ
simplifyView (œÜ ‚à® ‚ä§) = œÜ ‚à®‚ä§

simplifyView (‚ä• ‚àß œÜ) = ‚ä•‚àß œÜ
simplifyView (œÜ ‚àß ‚ä•) = œÜ ‚àß‚ä•
simplifyView (‚ä§ ‚àß œÜ) = ‚ä§‚àß œÜ
simplifyView (œÜ ‚àß ‚ä§) = œÜ ‚àß‚ä§

simplifyView (‚ä• ‚áí œÜ) = ‚ä•‚áí œÜ
simplifyView (œÜ ‚áí ‚ä•) = œÜ ‚áí‚ä•
simplifyView (‚ä§ ‚áí œÜ) = ‚ä§‚áí œÜ
simplifyView (œÜ ‚áí ‚ä§) = œÜ ‚áí‚ä§

simplifyView (‚ä• ‚áî œÜ) = ‚ä•‚áî œÜ
simplifyView (œÜ ‚áî ‚ä•) = œÜ ‚áî‚ä•
simplifyView (‚ä§ ‚áî œÜ) = ‚ä§‚áî œÜ
simplifyView (œÜ ‚áî ‚ä§) = œÜ ‚áî‚ä§

simplifyView œÜ = stop œÜ
```
~~~~~~~~

It is convenient to define the simplification procedure in two separate functions,

```
simplify1 simplify : Formula ‚Üí Formula
```

The first function !ref(simplify1) is non-recursive and it defines a single simplification step
in terms of the view of the formula:

```
simplify1 œÜ
  with simplifyView œÜ
... | ¬¨‚ä• = ‚ä§
... | ¬¨‚ä§ = ‚ä•
... | ¬¨¬¨ œà = œà
... | ‚ä•‚à® œà = œà
... | œà ‚à®‚ä• = œà
... | ‚ä§‚à® œà = ‚ä§
... | œà ‚à®‚ä§ = ‚ä§
... | ‚ä•‚àß œà = ‚ä•
... | œà ‚àß‚ä• = ‚ä•
... | ‚ä§‚àß œà = œà
... | œà ‚àß‚ä§ = œà
... | ‚ä•‚áí œà = ‚ä§
... | œà ‚áí‚ä• = ¬¨ œà
... | ‚ä§‚áí œà = œà
... | œà ‚áí‚ä§ = ‚ä§
... | ‚ä•‚áî œà = ¬¨ œà
... | œà ‚áî‚ä• = ¬¨ œà
... | ‚ä§‚áî œà = œà
... | œà ‚áî‚ä§ = œà
... | stop œà = œà
```

The second function !ref(simplify) takes care of the recursive structure of the formula in order to apply !ref(simplify1) "deeply"
(no view is used here):

```
simplify ‚ä• = ‚ä•
simplify ‚ä§ = ‚ä§
simplify (` p) = ` p
simplify (¬¨ œÜ) = simplify1 (¬¨ simplify œÜ)
simplify (œÜ ‚à® œà) = simplify1 (simplify œÜ ‚à® simplify œà)
simplify (œÜ ‚àß œà) = simplify1 (simplify œÜ ‚àß simplify œà)
simplify (œÜ ‚áí œà) = simplify1 (simplify œÜ ‚áí simplify œà)
simplify (œÜ ‚áî œà) = simplify1 (simplify œÜ ‚áî simplify œà)
```

!example(#example:simplify)
~~~~~
We can see our simplification procedure in action on some simple examples:

```
_ : simplify (¬¨ ¬¨ ¬¨ ¬¨ ` p‚ÇÄ) ‚â° ` p‚ÇÄ
_ = refl

_ : simplify (¬¨ (‚ä§ ‚àß ¬¨ ` p‚ÇÄ)) ‚â° ` p‚ÇÄ
_ = refl

_ : simplify (‚ä§ ‚àß ¬¨ ¬¨ (¬¨ ` p‚ÇÄ ‚à® ¬¨ ¬¨ ` p‚ÇÅ)) ‚â° ¬¨ ` p‚ÇÄ ‚à® ` p‚ÇÅ
_ = refl
```

Notice how applying simplification deeply in the formula enables further simplification.
~~~~~

## Correctness

We show that the simplification procedure preserves the meaning of the formula:

```
simplify1-sound : ‚àÄ œÜ ‚Üí
  ----------------
  simplify1 œÜ ‚ü∫ œÜ

simplify-sound : ‚àÄ œÜ ‚Üí
  ---------------
  simplify œÜ ‚ü∫ œÜ
```

!hide
~~~~
The definition of !ref(simplify1-sound) is by a case analysis based on !ref(simplifyView).
The use of the `--rewriting` option triggers automatic Boolean rewrites in the background
(such as `ff ‚à®ùîπ b ‚â° b`; c.f. [Booleans](../../part0/Booleans)),
which makes the proof straightforward.
~~~~
~~~~
```
simplify1-sound œÜ œ±
  with simplifyView œÜ
... | ¬¨‚ä• = refl
... | ¬¨‚ä§ = refl
... | ¬¨¬¨ œà = refl
... | ‚ä•‚à® œà = refl
... | œà ‚à®‚ä• = refl
... | ‚ä§‚à® œà = refl
... | œà ‚à®‚ä§ = refl
... | ‚ä•‚àß œà = refl
... | œà ‚àß‚ä• = refl
... | ‚ä§‚àß œà = refl
... | œà ‚àß‚ä§ = refl
... | ‚ä•‚áí œà = refl
... | œà ‚áí‚ä• = refl
... | ‚ä§‚áí œà = refl
... | œà ‚áí‚ä§ = refl
... | ‚ä•‚áî œà = refl
... | œà ‚áî‚ä• = refl
... | ‚ä§‚áî œà = refl
... | œà ‚áî‚ä§ = refl
... | stop œà = refl
```
~~~~

!hide
~~~~
The definition of !ref(simplify-sound) relies on !ref(simplify1-sound) and is by a routine structural induction.
~~~~
~~~~
```
simplify-sound ‚ä• œ± = refl
simplify-sound ‚ä§ œ± = refl
simplify-sound (` p) œ± = refl
simplify-sound (¬¨ œÜ) œ±
  rewrite simplify1-sound (¬¨ simplify œÜ) œ± |
          simplify-sound œÜ œ± = refl
simplify-sound (œÜ ‚à® œà) œ±
  rewrite simplify1-sound (simplify œÜ ‚à® simplify œà) œ± |
          simplify-sound œÜ œ± |
          simplify-sound œà œ± = refl
simplify-sound (œÜ ‚àß œà) œ±
  rewrite simplify1-sound (simplify œÜ ‚àß simplify œà) œ± |
          simplify-sound œÜ œ± |
          simplify-sound œà œ± = refl
simplify-sound (œÜ ‚áí œà) œ±
  rewrite simplify1-sound (simplify œÜ ‚áí simplify œà) œ± |
          simplify-sound œÜ œ± |
          simplify-sound œà œ± = refl
simplify-sound (œÜ ‚áî œà) œ±
  rewrite simplify1-sound (simplify œÜ ‚áî simplify œà) œ± |
          simplify-sound œÜ œ± |
          simplify-sound œà œ± = refl
```
~~~~

<!--

## Structure

We prove that !ref(simplify) produces a formula not containing the zero-ary connectives !ref(Formula)(‚ä•) and !ref(Formula)(‚ä§), unless this is all that there is in the formula.

-- data No[‚ä§,‚ä•] : Formula ‚Üí Set where
--   `_ : ‚àÄ p ‚Üí No[‚ä§,‚ä•] (` p)
--   ¬¨_ : No[‚ä§,‚ä•] œÜ ‚Üí No[‚ä§,‚ä•] (¬¨ œÜ)
--   _‚à®_ : No[‚ä§,‚ä•] œÜ ‚Üí No[‚ä§,‚ä•] œà ‚Üí No[‚ä§,‚ä•] (œÜ ‚à® œà)
--   _‚àß_ : No[‚ä§,‚ä•] œÜ ‚Üí No[‚ä§,‚ä•] œà ‚Üí No[‚ä§,‚ä•] (œÜ ‚àß œà)
--   _‚áí_ : No[‚ä§,‚ä•] œÜ ‚Üí No[‚ä§,‚ä•] œà ‚Üí No[‚ä§,‚ä•] (œÜ ‚áí œà)
--   _‚áî_ : No[‚ä§,‚ä•] œÜ ‚Üí No[‚ä§,‚ä•] œà ‚Üí No[‚ä§,‚ä•] (œÜ ‚áî œà)

-- data Simplified : Formula ‚Üí Set where
--   ‚ä• : Simplified ‚ä•
--   ‚ä§ : Simplified ‚ä§
--   no-‚ä§‚ä• : No[‚ä§,‚ä•] œÜ ‚Üí Simplified œÜ

-- simplified1-¬¨ : Simplified œÜ ‚Üí Simplified (simplify1 (¬¨ œÜ))
-- simplified1-¬¨ {œÜ} simp-œÜ = {!!}

-- simplified1-‚à® : Simplified œÜ ‚Üí Simplified œà ‚Üí Simplified (simplify1 (œÜ ‚à® œà))
-- simplified1-‚à® {œÜ} {œà} simp-œÜ simp-œà
--   with simplifyView (œÜ ‚à® œà)
-- ... | ‚ä•‚à® .œà = simp-œà
-- ... | .œÜ ‚à®‚ä• = simp-œÜ
-- ... | ‚ä§‚à® .œà = simp-œÜ
-- ... | .œÜ ‚à®‚ä§ = simp-œà
-- ... | stop .(œÜ ‚à® œà) = {! !} -- no information here, need to improve the view to be more precise

-- simplified : ‚àÄ œÜ ‚Üí Simplified (simplify œÜ)
-- simplified ‚ä• = ‚ä•
-- simplified ‚ä§ = ‚ä§
-- simplified (` p) = no-‚ä§‚ä• (` p)
-- simplified (¬¨ œÜ) = simplified1-¬¨ (simplified œÜ) 
-- simplified (œÜ ‚à® œà) = simplified1-‚à® (simplified œÜ) (simplified œà)
-- simplified (œÜ ‚àß œÜ‚ÇÇ) = {!!}
-- simplified (œÜ ‚áí œÜ‚ÇÇ) = {!!}
-- simplified (œÜ ‚áî œÜ‚ÇÇ) = {!!}

-->

# Duality

The connectives in the fragment `{‚ä•,‚ä§,¬¨,‚à®,‚àß}` have a fundamental duality:

* The two constants !remoteRef(part1)(Semantics)(Formula)(‚ä•) and !remoteRef(part1)(Semantics)(Formula)(‚ä§) are dual to each other.
* Negation !remoteRef(part1)(Semantics)(Formula)(¬¨_) is dual to itself.
* Conjunction !remoteRef(part1)(Semantics)(Formula)(_‚àß_) and disjunction !remoteRef(part1)(Semantics)(Formula)(_‚à®_) are dual to each other.

This captured by the following definition,
which given a formula `œÜ` constructs its *dual* `œÜ ‚Åª`
by recursively swaping each constructor with its dual:

```
infix 200 _‚Åª
_‚Åª : Formula ‚Üí Formula
‚ä• ‚Åª = ‚ä§
‚ä§ ‚Åª = ‚ä•
(` p) ‚Åª = ` p
(¬¨ œÜ) ‚Åª = ¬¨ œÜ ‚Åª
(œÜ ‚àß œà) ‚Åª = œÜ ‚Åª ‚à® œà ‚Åª
(œÜ ‚à® œà) ‚Åª = œÜ ‚Åª ‚àß œà ‚Åª
œÜ ‚Åª = œÜ
```

(In the last catch-all case we do not do anything,
since we will not apply dualisation outside the `{‚ä•,‚ä§,¬¨,‚à®,‚àß}` fragment.)

!example(#example:dualisation)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```
_ : ‚àÄ {œÜ œà} ‚Üí (œÜ ‚à® ¬¨ œà) ‚Åª ‚â° œÜ ‚Åª ‚àß ¬¨ œà ‚Åª
_ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the proofs that follow,
we want to capture the fact that a formula does not contain implications or bi-implications.
To this end, we define the following view:

```
data Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] : Formula ‚Üí Set where
  ‚ä• : Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] ‚ä•
  ‚ä§ : Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] ‚ä§
  `_ : ‚àÄ p ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (` p)
  ¬¨_ : ‚àÄ {œÜ} ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (¬¨ œÜ)
  _‚à®_ : ‚àÄ {œÜ œà} ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œà
    ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (œÜ ‚à® œà)
  _‚àß_ : ‚àÄ {œÜ œà} ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œà
    ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (œÜ ‚àß œà)
```

Notice that this view is *recursive*,
since we need to have views of subformulas in order to construct views of compound formulas.
We will not actually compute this view here,
but just use it as an additional assumption to the properties in the rest of the section
in order to exclude from consideration formulas involving implication or bi-impication.
(We will come back to this view in !chapterRef(part1)(CharacteristicFormulas) as part of functional completeness,
where we will provide a way to compute it; c.f. !remoteRef(part1)(CharacteristicFormulas)(funCompl[‚ä•,‚ä§,¬¨,‚à®,‚àß]).)

!exercise(#exercise:dual-involution)
~~~~~~
Show that dualisation is an involutive operator,
in the sense that applying it twice leaves the formula unchanged:

```
dual-involutive :
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí
  ----------
  œÜ ‚Åª ‚Åª  ‚â° œÜ
```

The extra assumption `Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ` dispenses us from considering formulas with implication or bi-implication.
~~~~~~
~~~~~~
```
dual-involutive ‚ä• = refl
dual-involutive ‚ä§ = refl
dual-involutive (` p) = refl
dual-involutive (¬¨ œÜ)
  rewrite dual-involutive œÜ = refl
dual-involutive (œÜ ‚àß œà)
  rewrite dual-involutive œÜ |
          dual-involutive œà = refl
dual-involutive (œÜ ‚à® œà)
  rewrite dual-involutive œÜ |
          dual-involutive œà = refl
```
~~~~~~

## Duality lemma

Dualisation satisfies a key semantic property.
For a valuation !ref(œ±), let `- œ±` be the *opposite valuation*,
which is obtained by negating the output of !ref(œ±):

```
-_ : Val ‚Üí Val
(- œ±) p = ¬¨ùîπ œ± p
```

The fundamental semantic property of dualisation is the following:

!lemma(#lemma:duality)(Duality lemma)
~~~~~~~~~~~~~~~~~~~~
```
duality : ‚àÄ {œÜ} œ± ‚Üí
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí
  --------------------------
  ‚ü¶ œÜ ‚Åª ‚üß œ± ‚â° ¬¨ùîπ ‚ü¶ œÜ ‚üß (- œ±)
```
~~~~~~~~~~~~~~~~~~~~

!hide
~~~~~~~~~~~
The proof follows a straightforward structural induction,
relying on de Morgan's laws !remoteRef(part1)(Semantics)(deMorganAnd) and !remoteRef(part1)(Semantics)(deMorganOr) for conjunction, resp., disjunction.
~~~~~~~~~~~
~~~~~~~~~~~
```
duality _ ‚ä• = refl
duality _ ‚ä§ = refl
duality {` p} œ± (` p)
  with œ± p
... | tt = refl
... | ff = refl
duality œ± (¬¨ œÜ)
  rewrite duality œ± œÜ = refl
duality {œÜ ‚àß œà} œ± (view-œÜ ‚àß view-œà)
  rewrite duality œ± view-œÜ |
          duality œ± view-œà = sym (deMorganAnd œÜ œà (- œ±))
duality {œÜ ‚à® œà} œ± (view-œÜ ‚à® view-œà)
  rewrite duality œ± view-œÜ |
          duality œ± view-œà = sym (deMorganOr œÜ œà (- œ±))
```
~~~~~~~~~~~

## Consequences

The next exercises explore some consequences of the duality lemma.

!exercise(#exercise:duality-equivalence-1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that dualisation preserves logical equivalence:

```
duality-equivalence-1 :
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œà ‚Üí
  œÜ ‚ü∫ œà ‚Üí
  ---------
  œÜ ‚Åª ‚ü∫ œà ‚Åª
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
duality-equivalence-1 view-œÜ view-œà œÜ‚ü∫œà œ±
  rewrite duality œ± view-œÜ |
          duality œ± view-œà |
          œÜ‚ü∫œà (- œ±) = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:duality-equivalence-2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
duality-equivalence-2 :
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œà ‚Üí
  œÜ ‚Åª ‚ü∫ œà ‚Åª ‚Üí
  -------
  œÜ ‚ü∫ œà
```

*Hint:* Use !ref(duality-equivalence-1) and the fact that dualisation preserves `{‚ä•,‚ä§,¬¨,‚à®,‚àß}` formulas:

```
dual-preservation :
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí
  ------------------------
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (œÜ ‚Åª)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We begin by proving that dualisation preserves `{‚ä•,‚ä§,¬¨,‚à®,‚àß}` formulas:

```
dual-preservation ‚ä• = ‚ä§
dual-preservation ‚ä§ = ‚ä•
dual-preservation (` p) = ` p
dual-preservation (¬¨ view-œÜ)
  = ¬¨ dual-preservation view-œÜ
dual-preservation (view-œÜ ‚àß view-œà)
  = dual-preservation view-œÜ ‚à® dual-preservation view-œà
dual-preservation (view-œÜ ‚à® view-œà)
  = dual-preservation view-œÜ ‚àß dual-preservation view-œà
```

With !ref(dual-preservation) in hand,
we can show !ref(duality-equivalence-2) by appealing to !ref(duality-equivalence-1):

```
duality-equivalence-2 {œÜ} {œà} view-œÜ view-œà œÜ‚Åª‚ü∫œà‚Åª œ± = ‚ü¶œÜ‚üßœ±‚â°‚ü¶œà‚üßœ± where

  ‚ü¶œÜ‚Åª‚Åª‚üßœ±‚â°‚ü¶œà‚Åª‚Åª‚üßœ± : ‚ü¶ œÜ ‚Åª ‚Åª ‚üß œ± ‚â° ‚ü¶ œà ‚Åª ‚Åª ‚üß œ±
  ‚ü¶œÜ‚Åª‚Åª‚üßœ±‚â°‚ü¶œà‚Åª‚Åª‚üßœ±
    rewrite duality-equivalence-1
      (dual-preservation view-œÜ)
      (dual-preservation view-œà) œÜ‚Åª‚ü∫œà‚Åª œ± = refl

  ‚ü¶œÜ‚üßœ±‚â°‚ü¶œà‚üßœ± : ‚ü¶ œÜ ‚üß œ± ‚â° ‚ü¶ œà ‚üß œ±
  ‚ü¶œÜ‚üßœ±‚â°‚ü¶œà‚üßœ±
    rewrite sym (dual-involutive view-œÜ) |
            sym (dual-involutive view-œà) = ‚ü¶œÜ‚Åª‚Åª‚üßœ±‚â°‚ü¶œà‚Åª‚Åª‚üßœ±
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:duality-tautology)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Show that, if `œÜ` is a tautology,
then the negation of its dual `¬¨ œÜ ‚Åª` is also a tautology:

```
duality-tautology : ‚àÄ {œÜ} ‚Üí
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí
  Tautology œÜ ‚Üí
  -----------------
  Tautology (¬¨ œÜ ‚Åª)
```

*Hint*: Use the fact that a tautology is logically equivalent to !remoteRef(part1)(Semantics)(Formula)(‚ä§);
c.f. !remoteRef(part1)(Semantics)(tautology-equivalence).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
duality-tautology {œÜ} view-œÜ tau-œÜ œ± = goal tau-œÜ where
  goal = Tautology œÜ       {-1-} by‚ü® fst (tautology-equivalence œÜ) ‚ü©
         œÜ ‚ü∫ ‚ä§             {-2-} by‚ü® duality-equivalence-1 view-œÜ ‚ä§ ‚ü©
         œÜ ‚Åª ‚ü∫ ¬¨ ‚ä§         {-3-} by‚ü® congF (œÜ ‚Åª) (¬¨ ‚ä§) (¬¨ ` p‚ÇÄ) p‚ÇÄ ‚ü©
         ¬¨ œÜ ‚Åª ‚ü∫ ¬¨ ¬¨ ‚ä§     {-4-} by‚ü® flip (trans-‚ü∫ (¬¨ œÜ ‚Åª) (¬¨ ¬¨ ‚ä§) ‚ä§) ¬¨¬¨‚ä§‚ü∫‚ä§ ‚ü©
         ¬¨ œÜ ‚Åª ‚ü∫ ‚ä§         {-5-} by‚ü® flip (snd (tautology-equivalence (¬¨ œÜ ‚Åª))) œ± ‚ü©
         ¬¨ùîπ ‚ü¶ œÜ ‚Åª ‚üß œ± ‚â° tt QED
```

TODO: provide somewhere an introduction to !remoteRef(part0)(Functions)(_by‚ü®_‚ü©_).

We comment on each step of the proof:

1) We begin by applying the left-to-right direction of !remoteRef(part1)(Semantics)(tautology-equivalence).
2) By !ref(duality-equivalence-1) we lift the equivalence to the dual formula `œÜ ‚Åª`.
3) By simple reasoning based on the fact that !remoteRef(part1)(Semantics)(_‚ü∫_) is a congruence,
we have that `¬¨ œÜ ‚Åª` is logically equivalent to `¬¨ ¬¨ ‚ä§`
4) Thanks to !remoteRef(part1)(Semantics)(¬¨¬¨‚ä§‚ü∫‚ä§), `¬¨ œÜ ‚Åª` is logically equivalent to !remoteRef(part1)(Semantics)(Formula)(‚ä§).
5) The proof is concluded by applying the right-to-left direction of !remoteRef(part1)(Semantics)(tautology-equivalence).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
