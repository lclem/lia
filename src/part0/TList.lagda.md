---
title: "TLists ðŸš§"
---

```
{-# OPTIONS --allow-unsolved-metas #-}

module part0.TList where
open import part0.List public

X_ : âˆ€ {â„“} â†’ Set â„“ * â†’ Set â„“
X Îµ = T
X (A âˆ· Îµ) = A
X (A âˆ· As@(_ âˆ· _)) = A Ã— X As

data TList {â„“} : Set â„“ * â†’ Set â„“ where
    BEGIN : TList Îµ
    _,_ : âˆ€ {A : Set â„“} {As : Set â„“ *} â†’ A â†’ TList As â†’ TList (A âˆ· As)

fetchElem : âˆ€ {â„“} {A : Set â„“} {As : Set â„“ *} â†’ TList As â†’ A âˆˆ As â†’ A
fetchElem (a , _) here = a
fetchElem (_ , as) (there AâˆˆAs) = fetchElem as AâˆˆAs

Funs : âˆ€ {â„“} (As : Set â„“ *) (B : Set â„“) â†’ Set â„“
Funs Îµ B = B
Funs (A âˆ· As) B = A â†’ Funs As B

infixl 7.2 _have_by_ _have_apply_at_ -- haveApplyAt

_have_by_ : âˆ€ {â„“} {As : Set â„“ *} â†’ TList As â†’ (A : Set â„“) â†’ A â†’ TList (A âˆ· As)
as have A by a = a , as

_have_apply_at_ : âˆ€ {â„“} {As Bs : Set â„“ *} â†’ TList Bs â†’ (B : Set â„“) â†’ Funs As B â†’ X (map (Î» A â†’ A âˆˆ Bs) As) â†’ TList (B âˆ· Bs)
_have_apply_at_ {â„“} {Îµ} {Bs} bs B b tt = b , bs
_have_apply_at_ {â„“} {A âˆ· Îµ} {Bs} bs B f AâˆˆBs = f (fetchElem bs AâˆˆBs) , bs
_have_apply_at_ {â„“} {A âˆ· As@(A' âˆ· As')} {Bs} bs B f (AâˆˆBs , pr) = _have_apply_at_ {â„“} {As} {Bs} bs B (f (fetchElem bs AâˆˆBs)) pr

infixl 7.1 _haveit haveit-syntax
_haveit : âˆ€ {â„“} {A : Set â„“} {As : Set â„“ *} â†’ TList (A âˆ· As) â†’ A
(a , _) haveit = a

haveit-syntax = _haveit
syntax haveit-syntax x = x END

_ : BEGIN
    have â„• apply 2 at tt
    have â„• apply suc at here
    have â„• apply _+_ at here , there here
    have â„• apply _+_ at here , there here
    â‰¡ 8 , 5 , 3 , 2 , BEGIN
_ = refl

backType : âˆ€ {â„“} {A : Set â„“} â†’ A * â†’ â„• â†’ Set â„“
backType {A = A} as 0 = âˆ€ {x} {xs : A *} â†’ x âˆˆ (as ++ x âˆ· xs)
backType as (suc n) = âˆ€ {a} â†’ backType (a âˆ· as) n

back : âˆ€ {â„“} {A : Set â„“} (n : â„•) â†’ backType Îµ n
back {A = A} n = go Îµ n where

  go : (as : A *) â†’ (n : â„•) â†’ backType as n
  go Îµ zero = here
  go (_ âˆ· as) zero
    with go as zero
  ... | ind = there ind
  go as (suc n) {a} = go (a âˆ· as) n

_ : BEGIN
    have â„• apply 2 at tt
    have â„• apply suc at back 0
    have â„• apply _+_ at back 0 , back 1
    have â„• apply _+_ at back 0 , back 1
    â‰¡ 8 , 5 , 3 , 2 , BEGIN
_ = refl
```

```
-- Funs As B â†’ X (map (Î» A â†’ A âˆˆ Bs) As) 
_have_by-magic : âˆ€ {As Bs : Set *} â†’ TList Bs â†’ (B : Set) â†’ TList (B âˆ· Bs)
bs have B by-magic = bs have B apply _ at _
```

```
-- tmap : âˆ€ {â„“} {As Bs : Vector (Set â„“) n} â†’ TVector {â„“} {n} (zipWith Fun As Bs) â†’ TList As â†’ TList Bs
-- tmap {Îµ} {Îµ} Îµ Îµ = Îµ
-- tmap {A âˆ· As} {B âˆ· Bs} (f âˆ· fs) (a âˆ· as) = f a âˆ· tmap fs as

-- tfilter :

-- dependent map over a list
-- dmap : âˆ€ {â„“ m} {A : Set â„“} {B : A â†’ Set m} â†’ Î  A B â†’ (as : A *) â†’ TList (map B as)
-- dmap _ Îµ = BEGIN
-- dmap f (a âˆ· as) = f a âˆ· dmap f as

-- filter-proof : âˆ€ {A : Set} {P : A â†’ Set} â†’ (P? : Decidable P) â†’ (as : A *) â†’ TList {! map (Dec âˆ˜ P) as  !}
-- filter-proof {A} {P} P? as = {!   !} where
--
--   as? : TList (map (Dec âˆ˜ P) as)
--   as? = dmap P? as
```