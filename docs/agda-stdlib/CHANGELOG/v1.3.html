<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Version 1.3 | Logic in Agda</title><!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Version 1.3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Propositional and fist-order logic developed with the proof assistant Agda." />
<meta property="og:description" content="Propositional and fist-order logic developed with the proof assistant Agda." />
<link rel="canonical" href="/lia/agda-stdlib/CHANGELOG/v1.3.html" />
<meta property="og:url" content="/lia/agda-stdlib/CHANGELOG/v1.3.html" />
<meta property="og:site_name" content="Logic in Agda" />
<script type="application/ld+json">
{"url":"/lia/agda-stdlib/CHANGELOG/v1.3.html","headline":"Version 1.3","description":"Propositional and fist-order logic developed with the proof assistant Agda.","@type":"WebPage","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/lia/assets/main.css">
  <!-- <link rel="stylesheet" href="/lia/assets/custom.css"> --><!-- Mathjax Support -->
  <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <!-- Load KaTeX -->
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.1.1/katex.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.1.1/katex.min.js"></script>
</head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/lia/">Logic in Agda</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/lia/part0/index/">Part 0</a>
                <a class="page-link" href="/lia/part1/index/">Part 1</a>
                <a class="page-link" href="/lia/part2/index/">Part 2</a>
                <a class="page-link" href="/lia/part3/index/">Part 3</a>
                <a class="page-link" href="/lia/part4/index/">Part 4</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

    <header class="post-header">
        <h1 class="post-title">Version 1.3</h1>
    </header>
  
    <p style="text-align:center;">
    
    
    
    
    
    
</p>

  
    <div class="post-content">
        <h2>Contents</h2>    
        <h1 id="version-13">Version 1.3</h1>

<p>The library has been tested using Agda version 2.6.1.</p>

<h2 id="highlights">Highlights</h2>

<ul>
  <li>
    <p>Monoid and ring tactics that are capable of solving equalities
without having to restate the equation.</p>
  </li>
  <li>
    <p>Binary and rose trees.</p>
  </li>
  <li>
    <p>Warnings when importing deprecated modules.</p>
  </li>
</ul>

<h2 id="bug-fixes">Bug-fixes</h2>

<ul>
  <li>
    <p>In <code class="language-plaintext highlighter-rouge">Data.Fin.Subset.Properties</code> the incorrectly named proof
<code class="language-plaintext highlighter-rouge">p⊆q⇒∣p∣&lt;∣q∣ : p ⊆ q → ∣ p ∣ ≤ ∣ q ∣</code> has been renamed to <code class="language-plaintext highlighter-rouge">p⊆q⇒∣p∣≤∣q∣</code>.</p>
  </li>
  <li>
    <p>In <code class="language-plaintext highlighter-rouge">Data.Nat.Properties</code> the incorrectly named proofs
<code class="language-plaintext highlighter-rouge">∀[m≤n⇒m≢o]⇒o&lt;n : (∀ {m} → m ≤ n → m ≢ o) → n &lt; o</code>
and <code class="language-plaintext highlighter-rouge">∀[m&lt;n⇒m≢o]⇒o≤n : (∀ {m} → m &lt; n → m ≢ o) → n ≤ o</code>
have been renamed to <code class="language-plaintext highlighter-rouge">∀[m≤n⇒m≢o]⇒n&lt;o</code> and <code class="language-plaintext highlighter-rouge">∀[m&lt;n⇒m≢o]⇒n≤o</code> respectively.</p>
  </li>
  <li>
    <p>Fixed the definition of <code class="language-plaintext highlighter-rouge">_⊓_</code> for <code class="language-plaintext highlighter-rouge">Codata.Conat</code>; it was mistakenly using
<code class="language-plaintext highlighter-rouge">_⊔_</code> in a recursive call.</p>
  </li>
  <li>
    <p>Fixed the type of <code class="language-plaintext highlighter-rouge">max≈v⁺</code> in <code class="language-plaintext highlighter-rouge">Data.List.Extrema</code>; it was mistakenly talking
about <code class="language-plaintext highlighter-rouge">min</code> rather than <code class="language-plaintext highlighter-rouge">max</code>.</p>
  </li>
  <li>
    <p>The module <code class="language-plaintext highlighter-rouge">⊆-Reasoning</code> in <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.BagAndSetEquality</code>
now exports the correct set of combinators.</p>
  </li>
  <li>
    <p>The record <code class="language-plaintext highlighter-rouge">DecStrictPartialOrder</code> now correctly re-exports the contents
of its <code class="language-plaintext highlighter-rouge">IsDecStrictPartialOrder</code> field.</p>
  </li>
</ul>

<h2 id="non-backwards-compatible-changes">Non-backwards compatible changes</h2>

<h4 id="changes-to-how-equational-reasoning-is-implemented">Changes to how equational reasoning is implemented</h4>

<ul>
  <li>
    <p>NOTE: <strong>Uses</strong> of equational reasoning remains unchanged. These changes should only
affect users who are renaming/hiding the library’s equational reasoning combinators.</p>
  </li>
  <li>Previously all equational reasoning combinators (e.g. <code class="language-plaintext highlighter-rouge">_≈⟨_⟩_</code>, <code class="language-plaintext highlighter-rouge">_≡⟨_⟩_</code>, <code class="language-plaintext highlighter-rouge">_≤⟨_⟩_</code>)
were defined in the following style:
    <pre><code class="language-agda">infixr 2 _≡⟨_⟩_

_≡⟨_⟩_ : ∀ x {y z : A} → x ≡ y → y ≡ z → x ≡ z
_ ≡⟨ x≡y ⟩ y≡z = trans x≡y y≡z
</code></pre>
    <p>The type checker therefore infers the RHS of the equational step from the LHS + the
type of the proof. For example for <code class="language-plaintext highlighter-rouge">x ≈⟨ x≈y ⟩ y ∎</code> it is inferred that <code class="language-plaintext highlighter-rouge">y ∎</code>
must have type <code class="language-plaintext highlighter-rouge">y IsRelatedTo y</code> from <code class="language-plaintext highlighter-rouge">x : A</code> and <code class="language-plaintext highlighter-rouge">x≈y : x ≈ y</code>.</p>
  </li>
  <li>
    <p>There are two problems with this. Firstly, it means that the reasoning combinators are
not compatible with macros (i.e. tactics) that attempt to automatically generate proofs
for <code class="language-plaintext highlighter-rouge">x≈y</code>. This is because the reflection machinary does not have access to the type of RHS
as it cannot be inferred. In practice this meant that the new reflective solvers
<code class="language-plaintext highlighter-rouge">Tactic.RingSolver</code> and <code class="language-plaintext highlighter-rouge">Tactic.MonoidSolver</code> could not be used inside the equational
reasoning. Secondly the inference procedure itself is slower as described in this
<a href="https://lists.chalmers.se/pipermail/agda/2016/009090.html">exchange</a>
on the Agda mailing list.</p>
  </li>
  <li>Therefore, as suggested on the mailing list, the order of arguments to the combinators
have been reversed so that instead the type of the proof is inferred from the LHS + RHS.
    <pre><code class="language-agda">infixr -2 step-≡

step-≡ : ∀ x {y z : A} → y ≡ z → x ≡ y → x ≡ z
step-≡ y≡z x≡y = trans x≡y y≡z

syntax step-≡ x y≡z x≡y = x ≡⟨ x≡y ⟩ y≡z
</code></pre>
    <p>where the <code class="language-plaintext highlighter-rouge">syntax</code> declaration is then used to recover the original order of the arguments.
This change enables the use of macros and anecdotally speeds up type checking by a
factor of 5.</p>
  </li>
  <li>
    <p>No changes are needed when defining new combinators, as the old and new styles are
compatible. Having said that you may want to switch to the new style for the benefits
described above.</p>
  </li>
  <li><strong>Changes required</strong>: The only drawback to this change is that hiding and renaming the
combinators no longer works  as before, as <code class="language-plaintext highlighter-rouge">_≡⟨_⟩_</code> etc. are now syntax instead of names.
For example instead of:
    <pre><code class="language-agda">open SetoidReasoning setoid public
  hiding (_≈⟨_⟩_) renaming (_≡⟨_⟩_ to _↭⟨_⟩_)
</code></pre>
    <p>one must now write :</p>
    <pre><code class="language-agda">private
  module Base = SetoidReasoning setoid
open Base public hiding (step-≈; step-≡)

infixr 2 step-↭
step-↭ = Base.step-≡
syntax step-↭ x y≡z x≡y = x ↭⟨ x≡y ⟩ y≡z
</code></pre>
    <p>This is more verbose than before, but we hope that the advantages outlined above
outweigh this minor inconvenience. (As an aside, it is hoped that at some point Agda might
provide the ability to rename syntax that automatically generates the above boilerplate).</p>
  </li>
</ul>

<h4 id="changes-to-the-algebra-hierarchy">Changes to the algebra hierarchy</h4>

<ul>
  <li>The following record definitions in <code class="language-plaintext highlighter-rouge">Algebra.Structures</code> have been changed.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IsCommutativeMonoid</code></li>
      <li><code class="language-plaintext highlighter-rouge">IsCommutativeSemiring</code></li>
      <li><code class="language-plaintext highlighter-rouge">IsRing</code></li>
    </ul>

    <p>In each case, the structure now requires fields for all the required properties,
rather than just an (arbitrary) minimal set of properties.</p>
  </li>
  <li>
    <p>For example, whereas the old definition of <code class="language-plaintext highlighter-rouge">IsCommutativeMonoid</code> required
the following fields:</p>

    <ul>
      <li>Associativity</li>
      <li>Left identity</li>
      <li>Commutativity</li>
    </ul>

    <p>the new definition also requires:</p>

    <ul>
      <li>Right identity.</li>
    </ul>
  </li>
  <li>
    <p>Previously, the justification for not including a right identity proof was that,
given left identity and commutativity, right identity can be proven. However,
omitting the right identity proof caused problems:</p>

    <ol>
      <li>It made the definition longer and more complex, as less code was reused.</li>
      <li>The forgetful map turning a commutative monoid into a monoid was not a
retraction of all maps which augment a monoid with commutativity. To see
that the forgetful map was not a retraction, notice that the augmentation
must have discarded the right identity proof as there was no field for it
in <code class="language-plaintext highlighter-rouge">IsCommutativeMonoid</code>.</li>
      <li>There was no easy way to give only the right identity proof, and have
the left identity proof be generically derived.</li>
    </ol>

    <p>Point 2, and in particular the fact that it did not hold definitionally,
causes problems when indexing over monoids and commutative monoids and
requires some compatibility between the two indexings.</p>
  </li>
  <li><strong>Changes required</strong>: We recover the old behaviour by introducing <em>biased</em>
structures, found in <code class="language-plaintext highlighter-rouge">Algebra.Structures.Biased</code>. In particular, one can
convert old instances of <code class="language-plaintext highlighter-rouge">IsCommutativeMonoid</code> to new instances using the
<code class="language-plaintext highlighter-rouge">isCommutativeMonoidˡ</code> function. For example:
    <pre><code class="language-agda">isCommutativeMonoid = record
  { isSemigroup = ...
  ; identityˡ   = ...
  ; comm        = ...
  }
</code></pre>
    <p>becomes:</p>
    <pre><code class="language-agda">open import Algebra.Structures.Biased

isCommutativeMonoid = isCommutativeMonoidˡ record
  { isSemigroup = ...
  ; identityˡ   = ...
  ; comm        = ...
  }
</code></pre>
  </li>
  <li>For <code class="language-plaintext highlighter-rouge">IsCommutativeSemiring</code>, we have <code class="language-plaintext highlighter-rouge">isCommutativeSemiringˡ</code>, and for
<code class="language-plaintext highlighter-rouge">IsRing</code>, we have <code class="language-plaintext highlighter-rouge">isRingWithoutAnnihilatingZero</code>.</li>
</ul>

<h4 id="tweak-to-definition-of-permutationrefl">Tweak to definition of <code class="language-plaintext highlighter-rouge">Permutation.refl</code></h4>

<ul>
  <li>The definition of <code class="language-plaintext highlighter-rouge">refl</code> in <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Permutation.Homogeneous/Setoid</code>
has been changed from
    <pre><code class="language-agda">refl  : ∀ {xs} → Permutation R xs xs
</code></pre>
    <p>to:</p>
    <pre><code class="language-agda">refl  : ∀ {xs ys} → Pointwise R xs ys → Permutation R xs ys
</code></pre>
    <p>The old definition did not allow for size preserving transformations of permutations
via pointwise equalities and hence made it difficult to prove termination of complicated
proofs and functions over permutations.</p>
  </li>
  <li>Correspondingly the proofs <code class="language-plaintext highlighter-rouge">isEquivalence</code> and <code class="language-plaintext highlighter-rouge">setoid</code> in <code class="language-plaintext highlighter-rouge">Permutation.Homogeneous</code>
now require that the base relation <code class="language-plaintext highlighter-rouge">R</code> is reflexive.</li>
</ul>

<h4 id="improved-safety-for-word-and-float">Improved safety for <code class="language-plaintext highlighter-rouge">Word</code> and <code class="language-plaintext highlighter-rouge">Float</code></h4>

<ul>
  <li>
    <p>Decidable equality over floating point numbers has been made safe and
so  <code class="language-plaintext highlighter-rouge">_≟_</code> has been moved from <code class="language-plaintext highlighter-rouge">Data.Float.Unsafe</code> to <code class="language-plaintext highlighter-rouge">Data.Float.Properties</code>.</p>
  </li>
  <li>
    <p>Decidable equality over words has been made safe and so <code class="language-plaintext highlighter-rouge">_≟_</code> has been
moved from <code class="language-plaintext highlighter-rouge">Data.Word.Unsafe</code> to <code class="language-plaintext highlighter-rouge">Data.Word.Properties</code>.</p>
  </li>
  <li>
    <p>The modules <code class="language-plaintext highlighter-rouge">Data.Word.Unsafe</code> and <code class="language-plaintext highlighter-rouge">Data.Float.Unsafe</code> have been removed
as there are no longer any unsafe operations.</p>
  </li>
</ul>

<h4 id="other">Other</h4>

<ul>
  <li>The following lemmas may have breaking changes in their computational
behaviour.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">transpose-inverse</code> in <code class="language-plaintext highlighter-rouge">Data.Fin.Permutation.Components</code></li>
      <li><code class="language-plaintext highlighter-rouge">decFinSubset</code> &amp; <code class="language-plaintext highlighter-rouge">all?</code> in <code class="language-plaintext highlighter-rouge">Data.Fin.Properties</code></li>
    </ul>

    <p>Definitions that are sensitive to the behaviour of these lemmas, rather than
just their existence, may need to be revised.</p>
  </li>
  <li>
    <p>The fixity level of <code class="language-plaintext highlighter-rouge">Data.List.Base</code>’s <code class="language-plaintext highlighter-rouge">_∷ʳ_</code> has been changed from 5 to 6.
This means that <code class="language-plaintext highlighter-rouge">x ∷ xs ∷ʳ y</code> and <code class="language-plaintext highlighter-rouge">x ++ xs ∷ʳ y</code> are not ambiguous
anymore: they both are parenthesised to the right (the more efficient
variant).</p>
  </li>
  <li>
    <p>In <code class="language-plaintext highlighter-rouge">Codata.Cowriter</code> and <code class="language-plaintext highlighter-rouge">Codata.Musical.Colist</code> the functions <code class="language-plaintext highlighter-rouge">splitAt</code>, <code class="language-plaintext highlighter-rouge">take</code>
and <code class="language-plaintext highlighter-rouge">take-⊑</code> have been changed to use bounded vectors as defined in
<code class="language-plaintext highlighter-rouge">Data.Vec.Bounded</code> instead of the deprecated <code class="language-plaintext highlighter-rouge">Data.BoundedVec</code>. The old proofs
still exist under the names <code class="language-plaintext highlighter-rouge">splitAt′</code>, <code class="language-plaintext highlighter-rouge">take′</code> and <code class="language-plaintext highlighter-rouge">take′-⊑</code> but have been
deprecated.</p>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Codata.Colist</code>, uses of <code class="language-plaintext highlighter-rouge">Data.BoundedVec</code> have been replaced with the more
up to date <code class="language-plaintext highlighter-rouge">Data.Vec.Bounded</code>.</li>
</ul>

<h2 id="deprecated-modules">Deprecated modules</h2>

<ul>
  <li>A warning is now raised whenever you import a deprecated module. This should
aid the transition to the new modules. These warnings can be disabled locally
by adding the pragma <code class="language-plaintext highlighter-rouge">{-# OPTIONS --warn=noUserWarning #-}</code> to the top of a module.</li>
</ul>

<p>The following modules have been renamed as part of a drive to improve
consistency across the library. The deprecated modules still exist and
therefore all existing code should still work, however use of the new names
is encouraged.</p>

<ul>
  <li>In <code class="language-plaintext highlighter-rouge">Algebra</code>:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algebra.FunctionProperties.Consequences.Core           ↦ Algebra.Consequences.Base
Algebra.FunctionProperties.Consequences.Propositional  ↦ Algebra.Consequences.Propositional
Algebra.FunctionProperties.Consequences                ↦ Algebra.Conseqeunces.Setoid
</code></pre></div>    </div>
  </li>
  <li>The sub-module <code class="language-plaintext highlighter-rouge">Lexicographic</code> in <code class="language-plaintext highlighter-rouge">Data.Induction.WellFounded</code> has been deprecated,
instead the new proofs of well-foundedness in <code class="language-plaintext highlighter-rouge">Data.Product.Relation.Binary.Lex.Strict</code>
should be used.</li>
</ul>

<h2 id="deprecated-names">Deprecated names</h2>

<p>The following deprecations have occurred as part of a drive to improve
consistency across the library. The deprecated names still exist and
therefore all existing code should still work, however use of the new names
is encouraged. Although not anticipated any time soon, they may eventually
be removed in some future release of the library. Automated warnings are
attached to all deprecated names to discourage their use.</p>

<ul>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Fin</code>:
    <pre><code class="language-agda">fromℕ≤  ↦ fromℕ&lt;
fromℕ≤″ ↦ fromℕ&lt;″
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Fin.Properties</code>
    <pre><code class="language-agda">fromℕ≤-toℕ       ↦ fromℕ&lt;-toℕ
toℕ-fromℕ≤       ↦ toℕ-fromℕ&lt;
fromℕ≤≡fromℕ≤″   ↦ fromℕ&lt;≡fromℕ&lt;″
toℕ-fromℕ≤″      ↦ toℕ-fromℕ&lt;″
isDecEquivalence ↦ ≡-isDecEquivalence
preorder         ↦ ≡-preorder
setoid           ↦ ≡-setoid
decSetoid        ↦ ≡-decSetoid
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.List.Relation.Unary.All.Properties</code>:
    <pre><code class="language-agda">Any¬→¬All  ↦  Any¬⇒¬All
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Data.Nat.Properties</code>:
    <pre><code class="language-agda">∀[m≤n⇒m≢o]⇒o&lt;n  ↦  ∀[m≤n⇒m≢o]⇒n&lt;o
∀[m&lt;n⇒m≢o]⇒o≤n  ↦  ∀[m&lt;n⇒m≢o]⇒n≤o
</code></pre>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">Algebra.Morphism.Definitions</code> and <code class="language-plaintext highlighter-rouge">Relation.Binary.Morphism.Definitions</code>
the type <code class="language-plaintext highlighter-rouge">Morphism A B</code> has been deprecated in favour of the standard
function notation <code class="language-plaintext highlighter-rouge">A → B</code>.</li>
</ul>

<h2 id="new-modules">New modules</h2>

<ul>
  <li>A hierarchy for algebraic modules:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algebra.Module
Algebra.Module.Bundles
Algebra.Module.Consequences
Algebra.Module.Construct.Biproduct
Algebra.Module.Construct.TensorUnit
Algebra.Module.Construct.Zero
Algebra.Module.Definitions
Algebra.Module.Definitions.Bi
Algebra.Module.Definitions.Left
Algebra.Module.Definitions.Right
Algebra.Module.Structures
Algebra.Module.Structures.Biased
</code></pre></div>    </div>
    <p>Supported are all of {left, right, bi} {semi} modules.</p>
  </li>
  <li>Morphisms over group and ring-like algebraic structures:
    <pre><code class="language-agda">Algebra.Morphism.GroupMonomorphism
Algebra.Morphism.RingMonomorphism
</code></pre>
  </li>
  <li>Bisimilarity relation for <code class="language-plaintext highlighter-rouge">Cowriter</code>.
    <pre><code class="language-agda">Codata.Cowriter.Bisimilarity
</code></pre>
  </li>
  <li>Wrapper for the erased modality, allows the storage of erased proofs
in a record and the use of projections to manipulate them without having
to turn on the unsafe option <code class="language-plaintext highlighter-rouge">--irrelevant-projections</code>.
    <pre><code class="language-agda">Data.Erased
</code></pre>
  </li>
  <li>Induction over finite subsets:
    <pre><code class="language-agda">Data.Fin.Subset.Induction
</code></pre>
  </li>
  <li>Unary predicate for lists in which all related elements are grouped together.
    <pre><code class="language-agda">Data.List.Relation.Unary.Grouped
Data.List.Relation.Unary.Grouped.Properties
</code></pre>
  </li>
  <li>Unary predicate for products in which the components both satisfy individual
unary predicates.
    <pre><code class="language-agda">Data.Product.Relation.Unary.All
</code></pre>
  </li>
  <li>New data type for dependent products in which the second component is irrelevant.
    <pre><code class="language-agda">Data.Refinement
Data.Refinement.Relation.Unary.All
</code></pre>
  </li>
  <li>New data type for binary and rose trees:
    <pre><code class="language-agda">Data.Tree.Binary
Data.Tree.Binary.Properties
Data.Tree.Binary.Relation.Unary.All
Data.Tree.Binary.Relation.Unary.All.Properties
Data.Tree.Rose
Data.Tree.Rose.Properties
</code></pre>
  </li>
  <li>New properties and functions over floats and words.
    <pre><code class="language-agda">Data.Float.Base
Data.Float.Properties
Data.Word.Base
Data.Word.Properties
</code></pre>
  </li>
  <li>Helper methods for using reflection with numeric data.
    <pre><code class="language-agda">Data.Nat.Reflection
Data.Fin.Reflection
</code></pre>
  </li>
  <li>Finer-grained breakdown of the reflection primitives, alongside
new utility functions for writing macros.
    <pre><code class="language-agda">Reflection.Abstraction
Reflection.Argument
Reflection.Argument.Information
Reflection.Argument.Relevance
Reflection.Argument.Visibility
Reflection.Definition
Reflection.Literal
Reflection.Meta
Reflection.Name
Reflection.Pattern
Reflection.Term
Reflection.TypeChecking.MonadSyntax
</code></pre>
  </li>
  <li>New tactics for monoid and ring solvers. See <code class="language-plaintext highlighter-rouge">README.Tactic.MonoidSolver/RingSolver</code> for details
    <pre><code class="language-agda">Tactic.MonoidSolver
Tactic.RingSolver
Tactic.RingSolver.NonReflective
</code></pre>
  </li>
</ul>

<h2 id="other-major-changes">Other major changes</h2>

<h4 id="improved-performance-of-decision-processes">Improved performance of decision processes</h4>

<ul>
  <li>
    <p>All definitions branching on a <code class="language-plaintext highlighter-rouge">Dec</code> value have been rewritten, wherever possible,
to branch only  on the boolean <code class="language-plaintext highlighter-rouge">does</code> field. Furthermore, branching on
the <code class="language-plaintext highlighter-rouge">proof</code> field has been made as late as possible, using the <code class="language-plaintext highlighter-rouge">invert</code> lemma from
<code class="language-plaintext highlighter-rouge">Relation.Nullary.Reflects</code>.</p>
  </li>
  <li>
    <p>For example, the old definition of <code class="language-plaintext highlighter-rouge">filter</code> in <code class="language-plaintext highlighter-rouge">Data.List.Base</code> used the
<code class="language-plaintext highlighter-rouge">yes</code> and <code class="language-plaintext highlighter-rouge">no</code> patterns, which desugared to the following:</p>
    <pre><code class="language-agda">filter : ∀ {P : Pred A p} → Decidable P → List A → List A
filter P? [] = []
filter P? (x ∷ xs) with P? x
... | false because ofⁿ _ = filter P? xs
... |  true because ofʸ _ = x ∷ filter P? xs
</code></pre>

    <p>Because the proofs (<code class="language-plaintext highlighter-rouge">ofⁿ _</code> and <code class="language-plaintext highlighter-rouge">ofʸ _</code>) are not giving us any information,
we do not need to match on them. We end up with the following definition,
where the <code class="language-plaintext highlighter-rouge">proof</code> field has been projected away.</p>

    <pre><code class="language-agda">filter : ∀ {P : Pred A p} → Decidable P → List A → List A
filter P? [] = []
filter P? (x ∷ xs) with does (P? x)
... | false = filter P? xs
... | true  = x ∷ filter P? xs
</code></pre>

    <p>Correspondingly, when proving a property of <code class="language-plaintext highlighter-rouge">filter</code>, we can often make a
similar change, but sometimes need the proof eventually. The following
example is adapted from <code class="language-plaintext highlighter-rouge">Data.List.Membership.Setoid.Properties</code>.</p>

    <pre><code class="language-agda">open Membership S using (_∈_)

∈-filter⁺ : ∀ {v xs} → v ∈ xs → P v → v ∈ filter P? xs
∈-filter⁺ {xs = x ∷ _} (here v≈x) Pv with P? x
-- There is no matching on the proof, so we can emit the result without
-- computing the proof at all.
... |  true because   _   = here v≈x
-- `invert` is used to get the proof just when it is needed.
... | false because [¬Px] = contradiction (resp v≈x Pv) (invert [¬Px])
-- In the remaining cases, we make no use of the proof.
∈-filter⁺ {xs = x ∷ _} (there v∈xs) Pv with does (P? x)
... | true  = there (∈-filter⁺ v∈xs Pv)
... | false = ∈-filter⁺ v∈xs Pv
</code></pre>
  </li>
</ul>

<h4 id="other-1">Other</h4>

<ul>
  <li>
    <p>The module <code class="language-plaintext highlighter-rouge">Reflection</code> is no longer <code class="language-plaintext highlighter-rouge">--unsafe</code>.</p>
  </li>
  <li>
    <p>Standardised the <code class="language-plaintext highlighter-rouge">Eq</code> modules in structures and bundles in <code class="language-plaintext highlighter-rouge">Relation.Binary</code> hierarchy.</p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IsDecTotalOrder.Eq</code> now exports <code class="language-plaintext highlighter-rouge">isDecPartialOrder</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">DecSetoid.Eq</code> now exports <code class="language-plaintext highlighter-rouge">partialSetoid</code> and <code class="language-plaintext highlighter-rouge">_≉_</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">Poset.Eq</code> and <code class="language-plaintext highlighter-rouge">TotalOrder.Eq</code> now export <code class="language-plaintext highlighter-rouge">setoid</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">DecTotalOrder.Eq</code> and <code class="language-plaintext highlighter-rouge">StrictTotalOrder.Eq</code> now export <code class="language-plaintext highlighter-rouge">decSetoid</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">DecTotalOrder.decSetoid</code> is now deprecated in favour of the above <code class="language-plaintext highlighter-rouge">DecTotalOrder.Eq.decSetoid</code>.</li>
    </ul>
  </li>
</ul>

<h2 id="other-minor-additions">Other minor additions</h2>

<ul>
  <li>Added new record to <code class="language-plaintext highlighter-rouge">Algebra.Bundles</code>:
    <pre><code class="language-agda">+-rawGroup : RawGroup c ℓ
</code></pre>
    <p>and the <code class="language-plaintext highlighter-rouge">CommutativeMonoid</code> record now exports <code class="language-plaintext highlighter-rouge">commutativeSemigroup</code>.</p>
  </li>
  <li>Added new definition to <code class="language-plaintext highlighter-rouge">Algebra.Definitions</code>:
    <pre><code class="language-agda">Interchangable _∘_ _∙_ = ∀ w x y z → ((w ∙ x) ∘ (y ∙ z)) ≈ ((w ∘ y) ∙ (x ∘ z))
</code></pre>
  </li>
  <li>Added new records to <code class="language-plaintext highlighter-rouge">Algebra.Morphism.Structures</code>:
    <pre><code class="language-agda">IsGroupHomomorphism (⟦_⟧ : A → B) : Set (a ⊔ ℓ₁ ⊔ ℓ₂)
IsGroupMonomorphism (⟦_⟧ : A → B) : Set (a ⊔ ℓ₁ ⊔ ℓ₂)
IsGroupIsomorphism  (⟦_⟧ : A → B) : Set (a ⊔ b ⊔ ℓ₁ ⊔ ℓ₂)
IsRingHomomorphism  (⟦_⟧ : A → B) : Set (a ⊔ ℓ₁ ⊔ ℓ₂)
IsRingMonomorphism  (⟦_⟧ : A → B) : Set (a ⊔ ℓ₁ ⊔ ℓ₂)
IsRingIsomorphism   (⟦_⟧ : A → B) : Set (a ⊔ b ⊔ ℓ₁ ⊔ ℓ₂)
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Algebra.Properties.Group</code>:
    <pre><code class="language-agda">⁻¹-injective   : x ⁻¹ ≈ y ⁻¹ → x ≈ y
⁻¹-anti-homo-∙ : (x ∙ y) ⁻¹ ≈ y ⁻¹ ∙ x ⁻¹
</code></pre>
  </li>
  <li>
    <p>In <code class="language-plaintext highlighter-rouge">Algebra.Structures</code> the record <code class="language-plaintext highlighter-rouge">IsCommutativeSemiring</code> now
exports <code class="language-plaintext highlighter-rouge">*-isCommutativeSemigroup</code>.</p>
  </li>
  <li>
    <p>Made <code class="language-plaintext highlighter-rouge">RawFunctor</code>,  <code class="language-plaintext highlighter-rouge">RawApplicative</code> and <code class="language-plaintext highlighter-rouge">IFun</code> more level polymorphic
in <code class="language-plaintext highlighter-rouge">Category.Functor</code>, <code class="language-plaintext highlighter-rouge">Category.Applicative</code> and <code class="language-plaintext highlighter-rouge">Category.Applicative.Indexed</code>
respectively.</p>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Codata.Colist</code>:
    <pre><code class="language-agda">drop   : ℕ → Colist A ∞ → Colist A ∞
concat : Colist (List⁺ A) i → Colist A i
</code></pre>
  </li>
  <li>Added new definitions to <code class="language-plaintext highlighter-rouge">Codata.Colist.Bisimilarity</code>:
    <pre><code class="language-agda">fromEq        : as ≡ bs → i ⊢ as ≈ bs
isEquivalence : IsEquivalence R → IsEquivalence (Bisim R i)
setoid        : Setoid a r → Size → Setoid a (a ⊔ r)
module ≈-Reasoning

++⁺  : Pointwise R as bs → Bisim R i xs ys → Bisim R i (fromList as ++ xs) (fromList bs ++ ys)
⁺++⁺ : Pointwise R (toList as) (toList bs) → Thunk^R (Bisim R) i xs ys → Bisim R i (as ⁺++ xs) (bs ⁺++ ys)
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Codata.Colist.Properties</code>:
    <pre><code class="language-agda">fromCowriter∘toCowriter≗id : i ⊢ fromCowriter (toCowriter as) ≈ as
length-∷                   : i ⊢ length (a ∷ as) ≈ 1 ℕ+ length (as .force)
length-replicate           : i ⊢ length (replicate n a) ≈ n
length-++                  : i ⊢ length (as ++ bs) ≈ length as + length bs
length-map                 : i ⊢ length (map f as) ≈ length as
length-scanl               : i ⊢ length (scanl c n as) ≈ 1 ℕ+ length as
replicate-+                : i ⊢ replicate (m + n) a ≈ replicate m a ++ replicate n a
map-replicate              : i ⊢ map f (replicate n a) ≈ replicate n (f a)
lookup-replicate           : All (a ≡_) (lookup k (replicate n a))
map-unfold                 : i ⊢ map f (unfold alg a) ≈ unfold (Maybe.map (Prod.map₂ f) ∘ alg) a
unfold-nothing             : alg a ≡ nothing → unfold alg a ≡ []
unfold-just                : alg a ≡ just (a′ , b) → i ⊢ unfold alg a ≈ b ∷ λ where .force → unfold alg a′
scanl-unfold               : i ⊢ scanl cons nil (unfold alg a) ≈ nil ∷ (λ where .force → unfold alg′ (a , nil))
map-alignWith              : i ⊢ map f (alignWith al as bs) ≈ alignWith (f ∘ al) as bs
length-alignWith           : i ⊢ length (alignWith al as bs) ≈ length as ⊔ length bs
map-zipWith                : i ⊢ map f (zipWith zp as bs) ≈ zipWith (λ a → f ∘ zp a) as bs
length-zipWith             : i ⊢ length (zipWith zp as bs) ≈ length as ⊓ length bs
drop-nil                   : i ⊢ drop {A = A} m [] ≈ []
drop-drop-fusion           : i ⊢ drop n (drop m as) ≈ drop (m ℕ.+ n) as
map-drop                   : i ⊢ map f (drop m as) ≈ drop m (map f as)
length-drop                : i ⊢ length (drop m as) ≈ length as ∸ m
length-cotake              : i ⊢ length (cotake n as) ≈ n
map-cotake                 : i ⊢ map f (cotake n as) ≈ cotake n (Stream.map f as)
drop-fromList-++-identity  : drop (length as) (fromList as ++ bs) ≡ bs
drop-fromList-++-≤         : m ≤ length as → drop m (fromList as ++ bs) ≡ fromList (drop m as) ++ bs
drop-fromList-++-≥         : m ≥ length as → drop m (fromList as ++ bs) ≡ drop (m ∸ length as) bs
drop-⁺++-identity          : drop (length as) (as ⁺++ bs) ≡ bs .force
map-chunksOf               : i ⊢ map (map f) (map f) (chunksOf n as) ≈ chunksOf n (map f as)
fromList-++                : i ⊢ fromList (as ++ bs) ≈ fromList as ++ fromList bs
fromList-scanl             : i ⊢ scanl c n (fromList as) ≈ fromList (scanl c n as)
map-fromList               : i ⊢ map f (fromList as) ≈ fromList (map f as)
length-fromList            : i co⊢ length (fromList as) ≈ fromℕ (length as)
fromStream-++              : i ⊢ fromStream (as ++ bs) ≈ fromList as ++ fromStream bs
fromStream-⁺++             : i ⊢ fromStream (as ⁺++ bs) ≈ fromList⁺ as ++ fromStream (bs .force)
fromStream-concat          : i ⊢ concat (fromStream ass) ≈ fromStream (concat ass)
fromStream-scanl           : i ⊢ scanl c n (fromStream as) ≈ fromStream (scanl c n as)
map-fromStream             : i ⊢ map f (fromStream as) ≈ fromStream (map f as)
</code></pre>
  </li>
  <li>Added new definitions to <code class="language-plaintext highlighter-rouge">Codata.Conat.Bisimilarity</code>:
    <pre><code class="language-agda">isEquivalence : IsEquivalence (i ⊢_≈_)
setoid        : Size → Setoid 0ℓ 0ℓ
module ≈-Reasoning
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Codata.Conat.Properties</code>:
    <pre><code class="language-agda">0∸m≈0 : ∀ m → i ⊢ zero ∸ m ≈ zero
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Bool</code>:
    <pre><code class="language-agda">not-injective : not x ≡ not y → x ≡ y
</code></pre>
  </li>
  <li>Added new function to <code class="language-plaintext highlighter-rouge">Data.Difference.List</code>:
    <pre><code class="language-agda">_∷ʳ_ : DiffList A → A → DiffList A
</code></pre>
  </li>
  <li>Added new properties to <code class="language-plaintext highlighter-rouge">Data.Fin.Properties</code>:
    <pre><code class="language-agda">lift-injective        : (∀ {x y} → f x ≡ f y → x ≡ y) → ∀ k {x y} → lift k f x ≡ lift k f y → x ≡ y
inject+-raise-splitAt : [ inject+ n , raise {n} m ] (splitAt m i) ≡ i
</code></pre>
  </li>
  <li>Added new properties to <code class="language-plaintext highlighter-rouge">Data.Fin.Subset</code>:
    <pre><code class="language-agda">_⊂_ : Subset n → Subset n → Set
_⊄_ : Subset n → Subset n → Set
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Fin.Subset.Properties</code>:
    <pre><code class="language-agda">s⊆s           : p ⊆ q → s ∷ p ⊆ s ∷ q
∣p∣≡n⇒p≡⊤     : ∣ p ∣ ≡ n → p ≡ ⊤

p∪∁p≡⊤        : p ∪ ∁ p ≡ ⊤
∣∁p∣≡n∸∣p∣    : ∣ ∁ p ∣ ≡ n ∸ ∣ p ∣
x∈p⇒x∉∁p      : x ∈ p → x ∉ ∁ p
x∈∁p⇒x∉p      : x ∈ ∁ p → x ∉ p
x∉∁p⇒x∈p      : x ∉ ∁ p → x ∈ p
x∉p⇒x∈∁p      : x ∉ p → x ∈ ∁ p

x≢y⇒x∉⁅y⁆     : x ≢ y → x ∉ ⁅ y ⁆
x∉⁅y⁆⇒x≢y     : x ∉ ⁅ y ⁆ → x ≢ y

∣p∩q∣≤∣p∣     : ∣ p ∩ q ∣ ≤ ∣ p ∣
∣p∩q∣≤∣q∣     : ∣ p ∩ q ∣ ≤ ∣ q ∣
∣p∩q∣≤∣p∣⊓∣q∣ : ∣ p ∩ q ∣ ≤ ∣ p ∣ ⊓ ∣ q ∣
∣p∣≤∣p∪q∣     : ∣ p ∣ ≤ ∣ p ∪ q ∣
∣q∣≤∣p∪q∣     : ∣ q ∣ ≤ ∣ p ∪ q ∣
∣p∣⊔∣q∣≤∣p∪q∣ : ∣ p ∣ ⊔ ∣ q ∣ ≤ ∣ p ∪ q ∣
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Integer.Properties</code>:
    <pre><code class="language-agda">suc[i]≤j⇒i&lt;j : sucℤ i ≤ j → i &lt; j
i&lt;j⇒suc[i]≤j : i &lt; j → sucℤ i ≤ j
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.List</code>:
    <pre><code class="language-agda">derun       : B.Decidable R → List A → List A
deduplicate : Decidable _R_ → List A → List A
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Equality.Setoid</code>:
    <pre><code class="language-agda">Any-resp-≋      : P Respects _≈_ → (Any P) Respects _≋_
All-resp-≋      : P Respects _≈_ → (All P) Respects _≋_
AllPairs-resp-≋ : R Respects₂ _≈_ → (AllPairs R) Respects _≋_
Unique-resp-≋   : Unique Respects _≋_
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.List.Base</code>:
    <pre><code class="language-agda">_?∷_  : Maybe A → List A → List A
_∷ʳ?_ : List A → Maybe A → List A
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Membership.Propositional.Properties</code>:
    <pre><code class="language-agda">∈-derun⁺       : z ∈ xs → z ∈ derun R? xs
∈-deduplicate⁺ : z ∈ xs → z ∈ deduplicate _≟_ xs
∈-derun⁻       : z ∈ derun R? xs → z ∈ xs
∈-deduplicate⁻ : z ∈ deduplicate R? xs → z ∈ xs
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Membership.Setoid.Properties</code>:
    <pre><code class="language-agda">∈-derun⁺       : _≈_ Respectsʳ R → z ∈ xs → z ∈ derun R? xs
∈-deduplicate⁺ : _≈_ Respectsʳ (flip R) → z ∈ xs → z ∈ deduplicate R? xs
∈-derun⁻       : z ∈ derun R? xs → z ∈ xs
∈-deduplicate⁻ : z ∈ deduplicate R? xs → z ∈ xs
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Unary.All.Properties</code>:
    <pre><code class="language-agda">derun⁺       : All P xs → All P (derun Q? xs)
deduplicate⁺ : All P xs → All P (deduplicate Q? xs)
filter⁻      : All Q (filter P? xs) → All Q (filter (¬? ∘ P?) xs) → All Q xs
derun⁻       : All P (derun Q? xs) → All P xs
deduplicate⁻ : All P (deduplicate Q? xs) → All P xs
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Unary.Any.Properties</code>:
    <pre><code class="language-agda">lookup-result : (p : Any P xs) → P (lookup p)
filter⁺       : (p : Any P xs) → Any P (filter Q? xs) ⊎ ¬ Q (Any.lookup p)
derun⁺        : P Respects Q → Any P xs → Any P (derun Q? xs)
deduplicate⁺  : P Respects (flip Q) → Any P xs → Any P (deduplicate Q? xs)
filter⁻       : Any P (filter Q? xs) → Any P xs
derun⁻        : Any P (derun Q? xs) → Any P xs
deduplicate⁻  : Any P (deduplicate Q? xs) → Any P xs
</code></pre>
  </li>
  <li>
    <p>The implementation of <code class="language-plaintext highlighter-rouge">↭-trans</code> has been altered in
<code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Permutation.Inductive</code> to avoid
adding unnecessary <code class="language-plaintext highlighter-rouge">refl</code>s, hence improving it’s performance.</p>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Permutation.Setoid</code>:
    <pre><code class="language-agda">↭-prep : xs ↭ ys → x ∷ xs ↭ x ∷ ys
↭-swap : xs ↭ ys → x ∷ y ∷ xs ↭ y ∷ x ∷ ys

steps  : xs ↭ ys → ℕ
</code></pre>
  </li>
  <li>Added new combinators to <code class="language-plaintext highlighter-rouge">PermutationReasoning</code> in <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Permutation.Setoid</code>:
    <pre><code class="language-agda">_≋⟨_⟩_  : x ≋ y → y IsRelatedTo z → x IsRelatedTo z
_≋˘⟨_⟩_ : y ≋ x → y IsRelatedTo z → x IsRelatedTo z
</code></pre>
  </li>
  <li>Added new functions to ` Data.List.Relation.Binary.Permutation.Setoid.Properties`:
    <pre><code class="language-agda">0&lt;steps              : (xs↭ys : xs ↭ ys) → 0 &lt; steps xs↭ys
steps-respˡ          : (ys≋xs : ys ≋ xs) (ys↭zs : ys ↭ zs) → steps (↭-respˡ-≋ ys≋xs ys↭zs) ≡ steps ys↭zs
steps-respʳ          : (xs≋ys : xs ≋ ys) (zs↭xs : zs ↭ xs) → steps (↭-respʳ-≋ xs≋ys zs↭xs) ≡ steps zs↭xs

split                : xs ↭ as ++ [ v ] ++ bs → ∃₂ λ ps qs → xs ≋ ps ++ [ v ] ++ qs
dropMiddle           : ws ++ vs ++ ys ↭ xs ++ vs ++ zs → ws ++ ys ↭ xs ++ zs
dropMiddleElement    : ws ++ [ v ] ++ ys ↭ xs ++ [ v ] ++ zs → ws ++ ys ↭ xs ++ zs
dropMiddleElement-≋  : ws ++ [ v ] ++ ys ≋ xs ++ [ v ] ++ zs → ws ++ ys ↭ xs ++ zs

filter⁺              : xs ↭ ys → filter P? xs ↭ filter P? ys
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.List.Relation.Binary.Pointwise</code>:
    <pre><code class="language-agda">Any-resp-Pointwise      : P Respects _∼_  → (Any P) Respects (Pointwise _∼_)
All-resp-Pointwise      : P Respects _∼_  → (All P) Respects (Pointwise _∼_)
AllPairs-resp-Pointwise : R Respects₂ _∼_ → (AllPairs R) Respects (Pointwise _∼_)
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Maybe.Properties</code>:
    <pre><code class="language-agda">map-nothing : ma ≡ nothing → map f ma ≡ nothing
map-just    : ma ≡ just a → map f ma ≡ just (f a)
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Nat.DivMod</code>:
    <pre><code class="language-agda">%-distribˡ-* : (m * n) % d ≡ ((m % d) * (n % d)) % d
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Nat.Properties</code>:
    <pre><code class="language-agda">m&lt;n+m         : n &gt; 0 → m &lt; n + m
∸-cancelʳ-≡   : o ≤ m → o ≤ n → m ∸ o ≡ n ∸ o → m ≡ n

⌊n/2⌋+⌈n/2⌉≡n : ⌊ n /2⌋ + ⌈ n /2⌉ ≡ n
⌊n/2⌋≤n       : ⌊ n /2⌋ ≤ n
⌊n/2⌋&lt;n       : ⌊ suc n /2⌋ &lt; suc n
⌈n/2⌉≤n       : ⌈ n /2⌉ ≤ n
⌈n/2⌉&lt;n       : ⌈ suc (suc n) /2⌉ &lt; suc (suc n)
⌊n/2⌋≤⌈n/2⌉   : ⌊ n /2⌋ ≤ ⌈ n /2⌉

⊔-pres-≤m     : n ≤ m → o ≤ m → n ⊔ o ≤ m
⊔-pres-&lt;m     : n &lt; m → o &lt; m → n ⊔ o &lt; m
⊓-pres-m≤     : m ≤ n → m ≤ o → m ≤ n ⊓ o
⊓-pres-m&lt;     : m &lt; n → m &lt; o → m &lt; n ⊓ o

*-isCommutativeSemigroup : IsCommutativeSemigroup _*_
*-commutativeSemigroup   : CommutativeSemigroup 0ℓ 0ℓ
</code></pre>
  </li>
  <li>Added new data and functions to <code class="language-plaintext highlighter-rouge">Data.String.Base</code>:
    <pre><code class="language-agda">data Alignment : Set
fromAlignment  : Alignment → ℕ → String → String

parens         : String → String
parensIfSpace  : String → String
braces         : String → String
intersperse    : String → List String → String
unwords        : List String → String
_&lt;+&gt;_          : String → String → String
padLeft        : Char → ℕ → String → String
padRight       : Char → ℕ → String → String
padBoth        : Char → Char → ℕ → String → String

rectangle      : Vec (ℕ → String → String) n → Vec String n → Vec String n
rectangleˡ     : Char → Vec String n → Vec String n
rectangleʳ     : Char → Vec String n → Vec String n
rectangleᶜ     : Char → Char → Vec String n → Vec String n
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.String.Unsafe</code>:
    <pre><code class="language-agda">toList-++        : toList (s ++ t) ≡ toList s ++ toList t
length-++        : length (s ++ t) ≡ length s + length t
length-replicate : length (replicate n c) ≡ n
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Data.Sum.Properties</code>:
    <pre><code class="language-agda">[,]-∘-distr     : f ∘ [ g , h ] ≗ [ f ∘ g , f ∘ h ]
[,]-map-commute : [ f′ , g′ ] ∘ (map f g) ≗ [ f′ ∘ f , g′ ∘ g ]
map-commute     : ((map f′ g′) ∘ (map f g)) ≗ map (f′ ∘ f) (g′ ∘ g)
</code></pre>
  </li>
  <li>
    <p>Improved the universe polymorphism of
<code class="language-plaintext highlighter-rouge">Data.Product.Relation.Binary.Lex.Strict/NonStrict</code>
so that the equality and order relations need not live at the
same universe level.</p>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Product.Relation.Binary.Lex.Strict</code>:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>×-wellFounded : WellFounded _&lt;₁_ → WellFounded _&lt;₂_ → WellFounded _&lt;ₗₑₓ_
</code></pre></div>    </div>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Rational.Properties</code>:
    <pre><code class="language-agda">↥-* : ↥ (p * q) ℤ.* *-nf p q ≡ ↥ p ℤ.* ↥ q
↧-* : ↧ (p * q) ℤ.* *-nf p q ≡ ↧ p ℤ.* ↧ q

toℚᵘ-homo-*                 : Homomorphic₂ toℚᵘ _*_ ℚᵘ._*_
toℚᵘ-isMagmaHomomorphism-*  : IsMagmaHomomorphism *-rawMagma ℚᵘ.*-rawMagma toℚᵘ
toℚᵘ-isMonoidHomomorphism-* : IsMonoidHomomorphism *-rawMonoid ℚᵘ.*-rawMonoid toℚᵘ
toℚᵘ-isMonoidMonomorphism-* : IsMonoidMonomorphism *-rawMonoid ℚᵘ.*-rawMonoid toℚᵘ
toℚᵘ-homo‿-                 : Homomorphic₁ toℚᵘ (-_) (ℚᵘ.-_)
toℚᵘ-isGroupHomomorphism-+  : IsGroupHomomorphism +-0-rawGroup ℚᵘ.+-0-rawGroup toℚᵘ
toℚᵘ-isGroupMonomorphism-+  : IsGroupMonomorphism +-0-rawGroup ℚᵘ.+-0-rawGroup toℚᵘ
toℚᵘ-isRingHomomorphism-|-* : IsRingHomomorphism +-*-rawRing ℚᵘ.+-*-rawRing toℚᵘ
toℚᵘ-isRingMonomorphism-|-* : IsRingMonomorphism +-*-rawRing ℚᵘ.+-*-rawRing toℚᵘ

*-assoc     : Associative _*_
*-comm      : Commutative _*_
*-identityˡ : LeftIdentity 1ℚ _*_
*-identityʳ : RightIdentity 1ℚ _*_
*-identity  : Identity 1ℚ _*_
+-inverseˡ  : LeftInverse 0ℚ -_ _+_
+-inverseʳ  : RightInverse 0ℚ -_ _+_
+-inverse   : Inverse 0ℚ -_ _+_
-‿cong      :  Congruent₁ (-_)

*-isMagma               : IsMagma _*_
*-isSemigroup           : IsSemigroup _*
*-1-isMonoid            : IsMonoid _*_ 1ℚ
*-1-isCommutativeMonoid : IsCommutativeMonoid _*_ 1ℚ
*-rawMagma              : RawMagma 0ℓ 0ℓ
*-rawMonoid             : RawMonoid 0ℓ 0ℓ
+-0-rawGroup            : RawGroup 0ℓ 0ℓ
+-*-rawRing             : RawRing 0ℓ 0ℓ
+-0-isGroup             : IsGroup _+_ 0ℚ (-_)
+-0-isAbelianGroup      : IsAbelianGroup _+_ 0ℚ (-_)
+-0-isRing              : IsRing _+_ _*_ -_ 0ℚ 1ℚ
+-0-group               : Group 0ℓ 0ℓ
+-0-abelianGroup        : AbelianGroup 0ℓ 0ℓ
*-distribˡ-+            : _*_ DistributesOverˡ _+_
*-distribʳ-+            : _*_ DistributesOverʳ _+_
*-distrib-+             : _*_ DistributesOver _+_
*-magma                 : Magma 0ℓ 0ℓ
*-semigroup             : Semigroup 0ℓ 0ℓ
*-1-monoid              : Monoid 0ℓ 0ℓ
*-1-commutativeMonoid   : CommutativeMonoid 0ℓ 0ℓ
+-*-isRing              : IsRing _+_ _*_ -_ 0ℚ 1ℚ
+-*-ring                : Ring 0ℓ 0ℓ
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Data.Rational.Unnormalised.Properties</code>:
    <pre><code class="language-agda">+-inverseˡ            : LeftInverse _≃_ 0ℚᵘ -_ _+_
+-inverseʳ            : RightInverse _≃_ 0ℚᵘ -_ _+_
+-inverse             : Inverse _≃_ 0ℚᵘ -_ _+_
-‿cong                : Congruent₁ _≃_ (-_)
+-0-isGroup           : IsGroup _≃_ _+_ 0ℚᵘ (-_)
+-0-group             : Group 0ℓ 0ℓ
+-0-isAbelianGroup    : IsAbelianGroup _≃_ _+_ 0ℚᵘ (-_)
+-0-abelianGroup      : AbelianGroup 0ℓ 0ℓ
*-zeroˡ               : LeftZero _≃_ 0ℚᵘ _*_
*-zeroʳ               : RightZero _≃_ 0ℚᵘ _*_
*-zero                : Zero _≃_ 0ℚᵘ _*_
*-distribˡ-+          : _DistributesOverˡ_ _≃_ _*_ _+_
*-distribʳ-+          : _DistributesOverʳ_ _≃_ _*_ _+_
*-distrib-+           : _DistributesOver_ _≃_ _*_ _+_
+-*-isRing            : IsRing _≃_ _+_ _*_ -_ 0ℚᵘ 1ℚ
+-*-ring              : Ring 0ℓ 0ℓ
+-0-rawGroup          : RawGroup 0ℓ 0ℓ
+-*-rawRing           : RawRing 0ℓ 0ℓ
+-*-isCommutativeRing : IsCommutativeRing _≃_ _+_ _*_ -_ 0ℚᵘ 1ℚᵘ
+-*-commutativeRing   : CommutativeRing 0ℓ 0ℓ
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.Vec.Base</code>:
    <pre><code class="language-agda">uncons    : Vec A (suc n) → A × Vec A n
length    : Vec A n → ℕ
transpose : Vec (Vec A n) m → Vec (Vec A m) n
</code></pre>
  </li>
  <li>Added new functions to <code class="language-plaintext highlighter-rouge">Data.Vec.Bounded.Base</code>:
    <pre><code class="language-agda">take : n → Vec≤ A m → Vec≤ A (n ⊓ m)
drop : n → Vec≤ A m → Vec≤ A (m ∸ n)

padLeft   : A → Vec≤ A n → Vec A n
padRight  : A → Vec≤ A n → Vec A n
padBoth : ∀ {n} → A → A → Vec≤ A n → Vec A n

rectangle : List (∃ (Vec≤ A)) → ∃ (List ∘ Vec≤ A)
</code></pre>
  </li>
  <li>Added new definitions to <code class="language-plaintext highlighter-rouge">Data.Word.Base</code>:
    <pre><code class="language-agda">_≈_ : Rel Word64 zero
_&lt;_ : Rel Word64 zero
</code></pre>
  </li>
  <li>Added utility function to <code class="language-plaintext highlighter-rouge">Function.Base</code>:
    <pre><code class="language-agda">it : {A : Set a} →  → A
</code></pre>
  </li>
  <li>Added new definitions to <code class="language-plaintext highlighter-rouge">Function.Bundles</code>:
    <pre><code class="language-agda">record BiInverse
record BiEquivalence

_↩↪_ : Set a → Set b → Set _
mk↩↪ : Inverseˡ f g₁ → Inverseʳ f g₂ → A ↩↪ B
</code></pre>
  </li>
  <li>Added new definitions to <code class="language-plaintext highlighter-rouge">Function.Structures</code>:
    <pre><code class="language-agda">record IsBiEquivalence (f : A → B) (g₁ : B → A) (g₂ : B → A)
record IsBiInverse     (f : A → B) (g₁ : B → A) (g₂ : B → A)
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Induction.WellFounded</code>:
    <pre><code class="language-agda">Acc-resp-≈            : Symmetric _≈_ → _&lt;_ Respectsʳ _≈_ → (Acc _&lt;_) Respects _≈_
some-wfRec-irrelevant : Some.wfRec P f x q ≡ Some.wfRec P f x q'
wfRecBuilder-wfRec    : All.wfRecBuilder P f x y y&lt;x ≡ All.wfRec P f y
unfold-wfRec          : All.wfRec P f x ≡ f x λ y _ → All.wfRec P f y
</code></pre>
  </li>
  <li>Added new definition in <code class="language-plaintext highlighter-rouge">Relation.Binary.Core</code>:
    <pre><code class="language-agda">DecidableEquality A = Decidable {A = A} _≡_
</code></pre>
  </li>
  <li>Added new proofs to <code class="language-plaintext highlighter-rouge">Relation.Binary.Construct.Union</code>:
    <pre><code class="language-agda">respˡ : L Respectsˡ ≈ → R Respectsˡ ≈ → (L ∪ R) Respectsˡ ≈
respʳ : L Respectsʳ ≈ → R Respectsʳ ≈ → (L ∪ R) Respectsʳ ≈
resp₂ : L Respects₂ ≈ → R Respects₂ ≈ → (L ∪ R) Respects₂ ≈
</code></pre>
  </li>
  <li>Added new proof to <code class="language-plaintext highlighter-rouge">Relation.Binary.Setoid.Properties</code>:
    <pre><code class="language-agda">≉-resp₂ : _≉_ Respects₂ _≈_
</code></pre>
  </li>
  <li>Added a new proof to <code class="language-plaintext highlighter-rouge">Relation.Nullary.Decidable</code>:
    <pre><code class="language-agda">isYes≗does : (P? : Dec P) → isYes P? ≡ does P?
</code></pre>
  </li>
</ul>

    </div>
  
    <p style="text-align:center;">
    
    
    
    
    
    
</p>

    <p class="p-name"> Last-modified:  </p>
  </article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/lia/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Logic in Agda</h2><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Lorenzo Clemente</li>
          <li><a class="u-email" href="mailto:clementelorenzo@gmail.com">clementelorenzo@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/lclem"><svg class="svg-icon"><use xlink:href="/lia/assets/minima-social-icons.svg#github"></use></svg> <span class="username">lclem</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>

<!-- Parse the Latex divs with Katex
<script type="text/javascript">
  $("script[type='math/tex']").replaceWith(
    function(){
      var tex = $(this).text();
      return katex.renderToString(tex, {displayMode: false});
  });
  
  $("script[type='math/tex; mode=display']").replaceWith(
    function(){
      var tex = $(this).text();
      return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
  });
</script>
-->

<script type="text/javascript" src="/lia/assets/hidebox.js"></script>
</body>

</html>
