---
title: Syntax and semantics of propositional logic üöß
---

In this chapter we introduce the syntax of propositional logic.

```
{-# OPTIONS --allow-unsolved-metas  #-}
open import part0.Naturals using (‚Ñï)

module part1.Semantics (n : ‚Ñï) where
open import part0.index public 
```

# Syntax

## Propositions {#prop-var}

The main building blocks of propositional logic are *propositional variables* $p, q, \dots$ (a.k.a. propositions),
and logical connectives (to be introduced in the next section).
Propositional variables can be implemented in a variety of ways,
such as strings "p", "q",...;
numbers 0, 1, ...; and many more.
Any such concrete representation will do,
provided that

* We can decide whether two given propositions are equal, and
* We can enumerate all propositions.

Our choice is to represent propositional variables with the datatype `Fin` of [finite sets](/part0/Fin).
The module parameter `n : ‚Ñï` allows us to name a fixed but arbitrary number of distinct propositions,
leading to the following definition (we omit the type annotation `Set`).

```
PropName = Fin (3 + n)
```

We use `p`, `q`, and `r` as generic variable names.
In examples, we use `p‚ÇÄ`, `p‚ÇÅ`, and `p‚ÇÇ` as the following concrete variables [^10+n]:

```
variable
  p : PropName

p‚ÇÄ p‚ÇÅ p‚ÇÇ : PropName
p‚ÇÄ = fzero
p‚ÇÅ = fsuc fzero 
p‚ÇÇ = fsuc (fsuc fzero)
```

[^10+n]:
    With the simpler and perhaps more natural definition `PropName = Fin n`
    we would not be able to name any specific proposition such as `p = fzero`
    since `n` is arbitrary and in particular it could be `0`,
    i.e., there could be no proposition at all.

Since propositions are modelled with `Fin`,
they inherit all the properties of the latter.
In particular, they enjoy decidable equality as initially required,

```
_ : p‚ÇÄ ‚â°? p‚ÇÄ ‚â° yes
_  = refl

_ : p‚ÇÄ ‚â°? p‚ÇÅ ‚â° no
_  = refl
```

and they can also be enumerated:

```
propNames : PropName *
propNames = enum

findPropName : ‚àÄ p ‚Üí p ‚àà propNames
findPropName = find
```

For example, the first variable in the enumeration is `p`
and the second is `q`:

```
_ : findPropName p‚ÇÄ ‚â° here
_ = refl

_ : findPropName p‚ÇÅ ‚â° there here
_ = refl
```

## Formulas

Formulas of propositional logic are constructed according to the following abstract syntax:

  $$ \varphi, \psi ‚à∑\equiv p \mid \bot \mid \top \mid \neg p \mid \varphi \land \psi \mid \varphi \lor \psi \mid \varphi \Rightarrow \psi \mid \varphi \Leftrightarrow \psi. $$

In other words, a formula is either

* a propositional variable $p$, or
* the *false* constant $\bot$ (pronounced "bottom"), or
* the *true* constant $\top$ (pronoounced "top"), or
* the *negation* $\neg \varphi$ of a formula $\varphi$, or
* the *conjunction* $\varphi \land \psi$ of two formulas $\varphi, \psi$, or
* the *disjunction* $\varphi \lor \psi$ of two formulas $\varphi, \psi$, or
* the *implication*[^implication-symbol] $\varphi \Rightarrow \psi$ of two formulas $\varphi, \psi$, or
* the *bi-implication* $\varphi \Leftrightarrow \psi$ of two formulas $\varphi, \psi$.

[^implication-symbol]: Other commonly used symbols for implication are "$\to$"
(which conflicts with Agda's function space constructor `‚Üí` and thus must be avoided),
and the old-fashioned "$\supset$" (which conflicts with common sense,
since in terms of the subset relation, and implication is more akin to "$‚äÜ$").

This straightforwardly translates to the following inductive type:

```
data Formula : Set where
    ‚ä• ‚ä§ : Formula
    `_ : (p : PropName) ‚Üí Formula
    ¬¨_ : (œÜ : Formula) ‚Üí Formula
    _‚àß_ _‚à®_ _‚áí_ _‚áî_ : (œÜ œà : Formula) ‚Üí Formula
```

Note that there is a slight notation overload for variables `` ` p`` w.r.t. the pure mathematical syntax $p$
since we have to explicitly name the `` `_ `` constructor. The syntax for the other connectives is identical.

We follow standard notational conventions and assume that `¬¨` is the operator with the highest priority
(i.e., it binds tighter than any other operator),
followed by `‚àß`, `‚à®` and `‚áí`, and `‚áî`:

```
infix 100 `_
infix 99 ¬¨_
infixr 98 _‚àß_
infixr 97 _‚à®_ _‚áí_
infixr 96 _‚áî_
```

All binary operators are right associative.
For instance, the formula

```
œÜ‚ÇÄ = ` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÄ ‚à® ` p‚ÇÅ
```

is syntactically identical to the formula

```
œÜ‚ÇÅ = ` p‚ÇÄ ‚à® ((¬¨ ` p‚ÇÄ) ‚à® ` p‚ÇÅ)
```

## Formula size

When defining functions on formulas,
a straightforward structural induction often suffices.
<!-- as in `props` [above](#occurring-propositions) -->
However, this is not always the case, and for more complicated recursive definitions
we need to use other forms of recursion,
such as [well-founded recursion](/part0/wf).
In such situations, it is useful to have a notion of *size* of a formula in order to show that the size decreases at each step.
The definition of formula size is given by structural induction on `Formula`:

```
size : Formula ‚Üí ‚Ñï
size ‚ä§ = 1
size ‚ä• = 1
size (` _) = 1
size (¬¨ œÜ) = 1 + size œÜ
size (œÜ ‚àß œà) = 1 + size œÜ + size œà
size (œÜ ‚à® œà) = 1 + size œÜ + size œà
size (œÜ ‚áí œà) = 1 + size œÜ + size œà
size (œÜ ‚áî œà) = 1 + size œÜ + size œà
```

!example(#example:size)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In the example formula `œÜ‚ÇÄ`, we have:

```
_ : size œÜ‚ÇÄ ‚â° 6
_ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As an exercise, we observe the following two inequalities satisfied by `size`.

!exercise(#exercise:size-neg)(`size-¬¨`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Prove that !ref(size) satisfies the following two inequalities:

```
size-¬¨ : ‚àÄ œÜ ‚Üí size œÜ ‚â§ size (¬¨ œÜ)
size-¬¨¬¨ : ‚àÄ œÜ ‚Üí size œÜ ‚â§ size (¬¨ ¬¨ œÜ)
```

(This will be used in the chapter on [Normal Forms](/part1/NormalForms).)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
size-¬¨ _ = n‚â§sucn
size-¬¨¬¨ œÜ = trans-‚â§ (size-¬¨ œÜ) (size-¬¨ (¬¨ œÜ)) 
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Equality

From time to time we need to check whether two formulas are syntactically equal,
i.e., are the very same formula.
For example, `` ` p ‚à® ` q`` is syntactically equal to itself,
but it is different from `` ` q ‚à® ` p``.

A na√Øve way to decide equality would be to list all the 8 √ó 8 = 64 pairs of constructors,

    instance eqFormula : Eq (Formula)
    _‚â°?_ {{eqFormula}} = go where
      go : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚â° œà)
      go ‚ä§ ‚ä§ = yes {proof = refl}
      go ‚ä§ ‚ä• = no {proof = Œª ()}
      go ‚ä§ (` _) = no {proof = Œª ()}
    ...

which is not practical [^no-split-on-catchall].
We will follow another, more interesting route.

1. First, we create an enumeration for the logical connectives,
for which we can easily prove decidability of equality.

2. Then, we injectively map formulas to labelled trees,
for which decidable equality is easier to prove [^dec-eq-reference].

[^no-split-on-catchall]:
    The issue is that Agda does not perform splits on a catch-all pattern `_`,
    thus preventing the following intuitive linear-sized code from working:
  
        instance eqFormula : Eq (Formula)
        _‚â°?_ {{eqFormula}} = go where
          go : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚â° œà)
          go ‚ä§ ‚ä§ = yes {proof = refl}
          go ‚ä§ _ = no {proof = Œª ()}
        ...
    This seems to be an often-made [complaint](https://github.com/agda/agda/issues/4804) about Agda.

[^dec-eq-reference]: We present a solution inspired from a discussion on
[stackoverflow](https://stackoverflow.com/questions/45150324/decidable-equality-in-agda-with-less-than-n2-cases).

**Step 1**.
We begin by defining an enumeration type for the formula constructors (connectives).

```
data Connective : Set where
  True False Not And Or Implies Iff : Connective
```

We can injectively map elements of `Connective` to the natural numbers `‚Ñï` in the obvious way.

```
c2‚Ñï : Connective ‚Üí ‚Ñï
c2‚Ñï True = 0
c2‚Ñï False = 1
c2‚Ñï Not = 2
c2‚Ñï And = 3
c2‚Ñï Or = 4
c2‚Ñï Implies = 5
c2‚Ñï Iff = 6
```

Thanks to pattern matching,
we only need to consider 7 cases (linearly many in the number of constructors of `Formula`)
to show that `c2‚Ñï` is injective:

```
c2‚Ñï-inj : Injective c2‚Ñï
c2‚Ñï-inj True True _ = refl
c2‚Ñï-inj False False _ = refl
c2‚Ñï-inj Not Not _ = refl
c2‚Ñï-inj And And _ = refl
c2‚Ñï-inj Or Or _ = refl
c2‚Ñï-inj Implies Implies _ = refl
c2‚Ñï-inj Iff Iff _ = refl
```

Since equality is decidable on natural numbers `‚Ñï`
and `Connective` maps injectively to `‚Ñï`,
equality is decidable for `Connective` as well.

```
instance eqConnective : Eq Connective
_‚â°?_ {{eqConnective}} = go where

  go : ‚àÄ C1 C2 ‚Üí Dec (C1 ‚â° C2)
  go C1 C2 with c2‚Ñï C1 ‚â°? c2‚Ñï C2
  -- by injectivity
  ... | yes {eq} = yes {proof = c2‚Ñï-inj C1 C2 eq}
  -- by functionality
  ... | no {neq} = no {proof = Œª{refl ‚Üí neq refl}}
```

**Step 2**.
We now injectively map formulas to `Connective ‚äé PropName`-labelled trees.
Since `Connective` and `PropName` have decidable equality,
so does their tagged union `Connective ‚äé VarName`.

```
FormulaTree = Tree (Connective ‚äé PropName)
```

We map formulas to trees by structural induction as follows:

```
Formula2Tree : Formula ‚Üí FormulaTree
Formula2Tree ‚ä§ = Node (left True) Œµ
Formula2Tree ‚ä• = Node (left False) Œµ
Formula2Tree (` p) = Node (right p) Œµ
Formula2Tree (¬¨ œÜ) = Node (left Not) ([ (Formula2Tree œÜ) ])
Formula2Tree (œÜ ‚àß œà) = Node (left And) ([ (Formula2Tree œÜ) (Formula2Tree œà) ])
Formula2Tree (œÜ ‚à® œà) = Node (left Or) ([ (Formula2Tree œÜ) (Formula2Tree œà) ])
Formula2Tree (œÜ ‚áí œà) = Node (left Implies) ([ (Formula2Tree œÜ) (Formula2Tree œà) ])
Formula2Tree (œÜ ‚áî œà) = Node (left Iff) ([ (Formula2Tree œÜ) (Formula2Tree œà) ])
```

!exercise(#exercise:Formula2Tree-inj)(`Formula2Tree-inj`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that the mapping `Formula2Tree` is injective.

```
Formula2Tree-inj : Injective Formula2Tree
```

*Hint:* Exploit the fact that the list constructor `_‚à∑_` is injective on both arguments:

```
_ = ‚à∑-inj-left , ‚à∑-inj-right
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
Formula2Tree-inj ‚ä§ ‚ä§ _ = refl
Formula2Tree-inj ‚ä• ‚ä• _ = refl
Formula2Tree-inj (` p) (` p) refl = refl
Formula2Tree-inj (¬¨ a) (¬¨ b) eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql))
... | refl = refl
Formula2Tree-inj (œÜ ‚àß œà) (œÜ' ‚àß œà') eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql)) |
       Formula2Tree-inj _ _ (‚à∑-inj-left (‚à∑-inj-right (Node-inj-right eql)))
... | refl | refl = refl
Formula2Tree-inj (œÜ ‚à® œà) (œÜ' ‚à® œà') eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql)) |
       Formula2Tree-inj _ _ (‚à∑-inj-left (‚à∑-inj-right (Node-inj-right eql)))
... | refl | refl = refl
Formula2Tree-inj (œÜ ‚áí œà) (œÜ' ‚áí œà') eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql)) |
       Formula2Tree-inj _ _ (‚à∑-inj-left (‚à∑-inj-right (Node-inj-right eql)))
... | refl | refl = refl
Formula2Tree-inj (œÜ ‚áî œà) (œÜ' ‚áî œà') eql
  with Formula2Tree-inj _ _ (‚à∑-inj-left (Node-inj-right eql)) |
       Formula2Tree-inj _ _ (‚à∑-inj-left (‚à∑-inj-right (Node-inj-right eql)))
... | refl | refl = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With this ingredients in hand,
we can finally show that `Formula` has decidable equality.

```
instance eqFormula : Eq Formula
_‚â°?_ {{eqFormula}} = go where
  
    go : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚â° œà)
    go œÜ œà with Formula2Tree œÜ ‚â°? Formula2Tree œà
    ... | yes {eq} = yes {proof = Formula2Tree-inj _ _ eq}
    ... | no {neq} = no {proof = Œª{refl ‚Üí neq refl}}
```

!example(#example:equality)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We demonstrate decidability of formula equality. We have

```
_ : (` p‚ÇÄ ‚à® ` p‚ÇÅ ‚â°? ` p‚ÇÄ ‚à® ` p‚ÇÅ) ‚â° yes
_ = refl
```

but

```
_ : (` p‚ÇÄ ‚à® ` p‚ÇÅ ‚â°? ` p‚ÇÅ ‚à® ` p‚ÇÄ) ‚â° no
_ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Semantics

In this section we introduce the semantics of classical logic.

## Valuations

An *valuation* is a mapping that associates a Boolean value `ùîπ` to each propositional variable.
We use `œ±`, `œ±'` for indicating a generic valuation.

```
Val = PropName ‚Üí ùîπ

variable œ± œ±' : Val
```

For instance, the valuation `œ±‚ÇÄ` below
assigns `ff` to `p‚ÇÄ` and `p‚ÇÅ`, and `tt` to every other variable:

```
œ±‚ÇÄ : Val
œ±‚ÇÄ = const tt [ p‚ÇÄ ‚Ü¶ ff ] [ p‚ÇÅ ‚Ü¶ ff ]
```

Since both propositions `PropName` and Boolean values `B` can be enumerated,
the same holds true for valuations `Val`,
which will be very useful to show that propositional logic is decidable.

```
vals : Val *
vals = enum

findVal : ‚àÄ œ± ‚Üí œ± ‚àà vals
findVal = find
```

## Semantics of propositional formulas

The semantics `‚ü¶ œÜ ‚üß œ± : ùîπ` of a formula `œÜ : Formula` in a given valuation `œ± : Val`
is a Boolean value (a.k.a. *truth value*) which is determined by
structural induction on `œÜ`:

* In the base cases `‚ä§` and `‚ä•`, the semantics is the corresponding truth value `tt`, resp., `ff`.
* In the variable case `` ` p ``, the semantics is `œ± p` as provided by the valuation `œ±`.
* In the negation case `¬¨ œÜ`, we inductively compute the semantics `‚ü¶ œÜ ‚üß œ±` of `œÜ`,
and then we apply the Boolean negation function `¬¨ùîπ : ùîπ ‚Üí ùîπ`.
* The remaining cases `œÜ ‚àß œà`, `œÜ ‚à® œà`, `œÜ ‚áí œà`, and `œÜ ‚áî œà` are similar.

Formally, we have the following definition:

```
infix 200 ‚ü¶_‚üß_

‚ü¶_‚üß_ : Formula ‚Üí Val ‚Üí ùîπ
‚ü¶ ‚ä• ‚üß œ± = ff
‚ü¶ ‚ä§ ‚üß œ± = tt
‚ü¶ ` p ‚üß œ± = œ± p
‚ü¶ ¬¨ œÜ ‚üß œ± = ¬¨ùîπ ‚ü¶ œÜ ‚üß œ±
‚ü¶ œÜ ‚àß œà ‚üß œ± = ‚ü¶ œÜ ‚üß œ± ‚àßùîπ ‚ü¶ œà ‚üß œ±
‚ü¶ œÜ ‚à® œà ‚üß œ± = ‚ü¶ œÜ ‚üß œ± ‚à®ùîπ ‚ü¶ œà ‚üß œ±
‚ü¶ œÜ ‚áí œà ‚üß œ± = ‚ü¶ œÜ ‚üß œ± ‚áíùîπ ‚ü¶ œà ‚üß œ±
‚ü¶ œÜ ‚áî œà ‚üß œ± = ‚ü¶ œÜ ‚üß œ± ‚áîùîπ ‚ü¶ œà ‚üß œ±
```

!example(#example:semantics)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For example, we can compute the semantics of some simple formulas
(recall that both `p‚ÇÄ` and `p‚ÇÅ` evaluate to `ff` under `œ±‚ÇÄ`):

```
_ : ‚ü¶ ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ ‚üß œ±‚ÇÄ ‚â° ff
_ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Invariance of the semantics

In principle the semantics `‚ü¶ œÜ ‚üß œ±` of a formula `œÜ` depends on the valuation `œ±`.
However, if a formula `œÜ` does not contain a certain proposition `p`
then clearly the value `œ± p` of `œ±` on `p` should not matter.
We now formalise this intuition by showing
that the semantics depends only on the propositional variables actually occurring in the formula.

We first compute the list `props œÜ` of occurrences of propositions in `œÜ`.
We proceed by structural induction on the formula:

```
props : Formula ‚Üí PropName *
props ‚ä§ = Œµ
props ‚ä• = Œµ
props (` p) = [ p ]
props (¬¨ œÜ) = props œÜ
props (œÜ ‚àß œà) = props œÜ ++ props œà
props (œÜ ‚à® œà) = props œÜ ++ props œà
props (œÜ ‚áí œà) = props œÜ ++ props œà
props (œÜ ‚áî œà) = props œÜ ++ props œà
```

Notice that `props œÜ` is an ordered *list* of all the occurrences of propositions in `œÜ`,
and thus contains duplicated elements if the same proposition appears multiple times.
For instance,

```
_ : props œÜ‚ÇÄ ‚â° [ p‚ÇÄ p‚ÇÄ p‚ÇÅ ]
_ = refl
```

A more natural idea would be to compute the *set* $\{ p , q \}$ of all propositions occurring in `œÜ‚ÇÄ`,
i.e., without duplications (and modulo commutativity). However 1) this would be more cumbersome to represent,
and 2) the current definition is good enough for most use cases of `props`.

We say that a proposition `p` is *fresh* w.r.t. `œÜ`
if `p` does not occur in `props œÜ`.

We can now formulate the invariance of the semantics.
Intuitively, if two valuations `œ±` and `œ±'` agree (i.e., have the same value)
on the propositions `props œÜ` occurring in `œÜ`,
then the semantics is the same:

```
invariance : ‚àÄ œÜ ‚Üí
  Agree œ± œ±' (props œÜ) ‚Üí
  ------------------
  ‚ü¶ œÜ ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ±'
```

!exercise(#exercise:invariance)(`invariance`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove invariance of the semantics.
*Hint*: Proceed by structural induction on formulas. In the variable case, use the assumption `Agree œ± œ±' (props œÜ)`.
In the inductive cases, use the fact that if `œ±` and `œ±'` agree on their value on the propositions in `œÜ ‚àß œà`,
then they do so on `œÜ`, resp., `œà`.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
invariance ‚ä§ agree = refl
invariance ‚ä• agree = refl
invariance (` p) agree = agree here
invariance (¬¨ œÜ) agree
  rewrite invariance œÜ agree = refl
invariance (œÜ ‚àß œà) agree
  rewrite invariance œÜ (Agree-‚äÜ agree ‚äÜ-++-left) |
          invariance œà (Agree-‚äÜ agree (‚äÜ-++-right (props œÜ))) = refl
invariance (œÜ ‚à® œà) agree
  rewrite invariance œÜ (Agree-‚äÜ agree ‚äÜ-++-left) |
          invariance œà (Agree-‚äÜ agree (‚äÜ-++-right (props œÜ))) = refl
invariance (œÜ ‚áí œà) agree
  rewrite invariance œÜ (Agree-‚äÜ agree ‚äÜ-++-left) |
          invariance œà (Agree-‚äÜ agree (‚äÜ-++-right (props œÜ))) = refl
invariance (œÜ ‚áî œà) agree
  rewrite invariance œÜ (Agree-‚äÜ agree ‚äÜ-++-left) |
          invariance œà (Agree-‚äÜ agree (‚äÜ-++-right (props œÜ))) = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:coincidence)(`coincidence`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the following *concidence lemma*
stating that the semantics of a formula `œÜ` does not change
if we update the value of the valuation `œ±` on a proposition `p`
not occurring in `œÜ`.

```
coincidence : ‚àÄ {b} œÜ ‚Üí
  p ‚àâ props œÜ ‚Üí
  ---------------------------
  ‚ü¶ œÜ ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ± [ p ‚Ü¶ b ]
```

*Hint* : Use invariance of the semantics.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
coincidence {p} {œ±} {b} œÜ p‚àâœÜ = invariance œÜ agree where

  agree : Agree œ± (œ± [ p ‚Ü¶ b ]) (props œÜ)
  agree = Agree-update-~‚àà (‚àâ‚Üí~‚àà p‚àâœÜ)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Substitution lemma

A basic operation on formulas is *substitution* of a propositional variable with another formula.

```
infix 101 _F[_‚Ü¶_]
_F[_‚Ü¶_] : Formula ‚Üí PropName ‚Üí Formula ‚Üí Formula
```

Intuitively, `œÜ F[ p ‚Ü¶ œà ]` is obtained from the formula `œÜ`
by replacing every occurrence of proposition `p` with `œà`.
Substitution binds tighter than `Formula` constructors[^substitution-notation],
e.g., ¬¨ œÜ F[ p ‚Ü¶ Œæ ]` is interpreted as `¬¨ (œÜ F[ p ‚Ü¶ Œæ ])`.

[^substitution-notation]: Recall that the similar notation `_[_‚Ü¶_]`
is reserved for function updates.

```
‚ä§ F[ _ ‚Ü¶ Œæ ] = ‚ä§
‚ä• F[ p ‚Ü¶ Œæ ] = ‚ä•
(` q) F[ p ‚Ü¶ Œæ ] with p ‚â°? q
... | yes = Œæ
... | no = ` q
(¬¨ œÜ) F[ p ‚Ü¶ Œæ ] = ¬¨ œÜ F[ p ‚Ü¶ Œæ ]
(œÜ ‚àß œà) F[ p ‚Ü¶ Œæ ] = œÜ F[ p ‚Ü¶ Œæ ] ‚àß œà F[ p ‚Ü¶ Œæ ]
(œÜ ‚à® œà) F[ p ‚Ü¶ Œæ ] = œÜ F[ p ‚Ü¶ Œæ ] ‚à® œà F[ p ‚Ü¶ Œæ ]
(œÜ ‚áí œà) F[ p ‚Ü¶ Œæ ] = œÜ F[ p ‚Ü¶ Œæ ] ‚áí œà F[ p ‚Ü¶ Œæ ]
(œÜ ‚áî œà) F[ p ‚Ü¶ Œæ ] = œÜ F[ p ‚Ü¶ Œæ ] ‚áî œà F[ p ‚Ü¶ Œæ ]
```

!example(#example:substitution)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For example, we have

```
_ : (` p‚ÇÄ ‚à® ` p‚ÇÅ) F[ p‚ÇÅ ‚Ü¶ ` p‚ÇÅ ‚à® ` p‚ÇÇ ] ‚â° ` p‚ÇÄ ‚à® ` p‚ÇÅ ‚à® ` p‚ÇÇ
_ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:parallel-substitution)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
From time to time it is useful to substitute in parallel two propositions `p` and `q` by `œà`, resp., `Œæ`,
written `œÜ F2[ p , q ‚Ü¶ œà , Œæ ]`.
For example,

      ` p‚ÇÄ ‚à® ` p‚ÇÅ F2[ p‚ÇÄ , p‚ÇÅ ‚Ü¶ p‚ÇÅ , p‚ÇÄ ] ‚â° ` p‚ÇÅ ‚à® ` p‚ÇÄ

Provide a definition of parallel substitution:

```
infix 101 _F2[_,_‚Ü¶_,_]
_F2[_,_‚Ü¶_,_] : Formula ‚Üí PropName ‚Üí PropName ‚Üí Formula ‚Üí Formula ‚Üí Formula
```

What happens if `p ‚â° q` ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
‚ä• F2[ p , q ‚Ü¶ œà , Œæ ] = ‚ä•

‚ä§ F2[ p , q ‚Ü¶ œà , Œæ ] = ‚ä§

(` r) F2[ p , q ‚Ü¶ œà , Œæ ]
  with p ‚â°? r
... | yes = œà
... | no
  with q ‚â°? r
... | yes = Œæ
... | no = ` r

(¬¨ œÜ) F2[ p , q ‚Ü¶ œà , Œæ ] = ¬¨ œÜ F2[ p , q ‚Ü¶ œà , Œæ ]

(œÜ‚ÇÅ ‚àß œÜ‚ÇÇ) F2[ p , q ‚Ü¶ œà , Œæ ] = œÜ‚ÇÅ F2[ p , q ‚Ü¶ œà , Œæ ] ‚àß œÜ‚ÇÇ F2[ p , q ‚Ü¶ œà , Œæ ]

(œÜ‚ÇÅ ‚à® œÜ‚ÇÇ) F2[ p , q ‚Ü¶ œà , Œæ ] = œÜ‚ÇÅ F2[ p , q ‚Ü¶ œà , Œæ ] ‚à® œÜ‚ÇÇ F2[ p , q ‚Ü¶ œà , Œæ ]

(œÜ‚ÇÅ ‚áí œÜ‚ÇÇ) F2[ p , q ‚Ü¶ œà , Œæ ] = œÜ‚ÇÅ F2[ p , q ‚Ü¶ œà , Œæ ] ‚áí œÜ‚ÇÇ F2[ p , q ‚Ü¶ œà , Œæ ]

(œÜ‚ÇÅ ‚áî œÜ‚ÇÇ) F2[ p , q ‚Ü¶ œà , Œæ ] = œÜ‚ÇÅ F2[ p , q ‚Ü¶ œà , Œæ ] ‚áî œÜ‚ÇÇ F2[ p , q ‚Ü¶ œà , Œæ ]
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The main property of substitution regards its interaction with the semantics
as expressed as the following *substitution lemma*:

```
substitution : ‚àÄ œÜ p Œæ œ± ‚Üí
  --------------------------------------------
  ‚ü¶ œÜ F[ p ‚Ü¶ Œæ ] ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ± [ p ‚Ü¶ ‚ü¶ Œæ ‚üß œ± ]
```

!exercise(#exercise:substitution)(`substitution`) 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the substitution lemma.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
substitution ‚ä§ p Œæ œ± = refl
substitution ‚ä• p Œæ œ± = refl
substitution (` q) p Œæ œ± with p ‚â°? q
... | yes {refl} = refl
... | no = refl
substitution (¬¨ œÜ) p Œæ œ± rewrite substitution œÜ p Œæ œ± = refl
substitution (œÜ ‚àß œà) p Œæ œ± rewrite substitution œÜ p Œæ œ± | substitution œà p Œæ œ± = refl
substitution (œÜ ‚à® œà) p Œæ œ± rewrite substitution œÜ p Œæ œ± | substitution œà p Œæ œ± = refl
substitution (œÜ ‚áí œà) p Œæ œ± rewrite substitution œÜ p Œæ œ± | substitution œà p Œæ œ± = refl
substitution (œÜ ‚áî œà) p Œæ œ± rewrite substitution œÜ p Œæ œ± | substitution œà p Œæ œ± = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A *variable renaming* is a special substitution of the form ``œÜ F[ p ‚Ü¶ ` q ]``.
It is convenient to state the substitution lemma in the special case of variable renamings:

```
renamings : ‚àÄ œÜ p q œ± ‚Üí
  ------------------------------------------
  ‚ü¶ œÜ F[ p ‚Ü¶ ` q ] ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ± [ p ‚Ü¶ œ± q ]
renamings œÜ p q œ± = substitution œÜ p (` q) œ± 
```

!exercise(#exercise:subst-id)(`subst-id`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that a substitution `œÜ F[ p ‚Ü¶ Œæ ]` does not alter the formula `œÜ`
if the variable `p` does not actually appear in `œÜ`:

```
subst-id : ‚àÄ œÜ p Œæ ‚Üí p ~‚àà props œÜ ‚Üí œÜ F[ p ‚Ü¶ Œæ ] ‚â° œÜ

aux-left = ~‚àà-++1
aux-right = ~‚àà-++2
```

*Hint:* Proceed by structural induction,
using the assumption `p ~‚àà props œÜ` in the variable case;
the two auxiliary functions `aux-left` and `aux-right` will be useful in the inductive case.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
subst-id ‚ä§ p Œæ p~‚ààœÜ = refl
subst-id ‚ä• p Œæ p~‚ààœÜ = refl
subst-id (` q) p Œæ p~‚ààœÜ with p ‚â°? q
-- contradiction
... | yes {refl} = F-elim (p~‚ààœÜ here)
... | no = refl 
subst-id (¬¨ œÜ) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ p~‚ààœÜ = refl
subst-id (œÜ ‚àß œà) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ (aux-left p~‚ààœÜ) |
          subst-id œà p Œæ (aux-right (props œÜ) p~‚ààœÜ) = refl 
subst-id (œÜ ‚à® œà) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ (aux-left p~‚ààœÜ) |
          subst-id œà p Œæ (aux-right (props œÜ) p~‚ààœÜ) = refl 
subst-id (œÜ ‚áí œà) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ (aux-left p~‚ààœÜ) |
          subst-id œà p Œæ (aux-right (props œÜ) p~‚ààœÜ) = refl 
subst-id (œÜ ‚áî œà) p Œæ p~‚ààœÜ
  rewrite subst-id œÜ p Œæ (aux-left p~‚ààœÜ) |
          subst-id œà p Œæ (aux-right (props œÜ) p~‚ààœÜ) = refl 
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:rename-undo)(`rename-undo`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Let `œÜ : Formula` be a formula and `p q : PropName` two propositions.
Prove that a double substitution ``œÜ F[ p ‚Ü¶ ` q ] F[ q ‚Ü¶ ` p ]`` does not change the formula `œÜ`
if the variable `q` does not occur in `œÜ`:

```
rename-undo : ‚àÄ œÜ p q ‚Üí q ‚àâ props œÜ ‚Üí œÜ F[ p ‚Ü¶ ` q ] F[ q ‚Ü¶ ` p ] ‚â° œÜ
```

**Warning**: `q ‚àâ props œÜ` here is different from `q ~‚àà props œÜ`.
While the latter is just an abbreviation for `~ (q ‚àà props œÜ)`
and thus it provides indirect evidence that `q` is not in `props œÜ`,
the former provides direct evidence that `q` is not in `props œÜ`
and thus it is stronger.
The two happen to be equivalent thanks to the coversion functions

```
_ = ~‚àà‚Üí‚àâ , ‚àâ‚Üí~‚àà
```

*Hint:* Proceed by induction on the evidence `q ‚àâ props œÜ` that `q` is not in `œÜ`.
The following two auxiliary functions will be useful in the inductive cases:

```
_ = ‚àâ-++1 , ‚àâ-++2
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
rename-undo ‚ä§ p q q‚àâœÜ = refl
rename-undo ‚ä• p q q‚àâœÜ = refl

rename-undo (` r) p q (notThere q‚â¢r _)
  with refl-‚â°? q
... | q‚â°?q‚â°yes
  with p ‚â°? r
... | yes {refl} rewrite q‚â°?q‚â°yes = refl 
... | no
  with q ‚â°? r
... | yes {refl} = x‚â¢x-elim q‚â¢r
... | no = refl 

rename-undo (¬¨ œÜ) p q q‚àâœÜ
  rewrite rename-undo œÜ p q q‚àâœÜ = refl

rename-undo (œÜ ‚àß œà) p q q‚àâœÜ
  rewrite rename-undo œÜ p q (‚àâ-++1 q‚àâœÜ) |
          rename-undo œà p q (‚àâ-++2 {as = props œÜ} q‚àâœÜ)
  = refl
  
rename-undo (œÜ ‚à® œà) p q q‚àâœÜ
  rewrite rename-undo œÜ p q (‚àâ-++1 q‚àâœÜ) |
          rename-undo œà p q (‚àâ-++2 {as = props œÜ} q‚àâœÜ)
  = refl
  
rename-undo (œÜ ‚áí œà) p q q‚àâœÜ
  rewrite rename-undo œÜ p q (‚àâ-++1 q‚àâœÜ) |
          rename-undo œà p q (‚àâ-++2 {as = props œÜ} q‚àâœÜ)
  = refl
  
rename-undo (œÜ ‚áî œà) p q q‚àâœÜ
  rewrite rename-undo œÜ p q (‚àâ-++1 q‚àâœÜ) |
          rename-undo œà p q (‚àâ-++2 {as = props œÜ} q‚àâœÜ)
  = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Tautology, entailment, and equivalence

### Tautology

A *tautology* is a formula that evaluates to `tt` under every valuation.

```
Tautology : Formula ‚Üí Set
Tautology œÜ = ‚àÄ[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â° tt
```

For instance the *law of excluded middle* `` ` p ‚à® ¬¨ ` p ``,
which amounts to say that the propositional variable `p` has either the value `tt` or `ff`,
is a tautology:

```
LEM : Tautology (` p ‚à® ¬¨ ` p)
LEM {p} œ± with œ± p
... | tt = refl
... | ff = refl
```

On the other hand, `` ` p `` is not a tautology since the (any) valuation that maps `p` to `ff`
(such as `const ff`) does not satisfy it:

```
_ : ~ Tautology (` p)
_ = Œª tau ‚Üí let ff‚â°tt = tau (const ff) in ff‚â¢tt ff‚â°tt
```

Since we can enumerate all valuations `œ± : Val`
and the equality `‚ü¶ œÜ ‚üß œ± ‚â° tt` is decidable,
we can *decide* whether `œÜ` is a tautology:

```
Tautology? : Decidable Tautology
Tautology? œÜ = ‚àÄ?[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â°? tt
```

For instance, we can check that `` ` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÄ `` is a tautology,
while `` ` p‚ÇÄ ‚à® ` p‚ÇÅ `` is not by computation,
where `p‚ÇÄ` and `p‚ÇÅ` are two concrete propositions.

```
_ : n ‚â° 0 ‚Üí erase (Tautology? (` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÄ)) ‚â° tt
_ = Œª{refl ‚Üí refl}

_ : n ‚â° 0 ‚Üí erase (Tautology? (` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÅ)) ‚â° ff
_ = Œª{refl ‚Üí refl}
```

(Note that we need to assume that `n` is some concrete number here,
allowing us to actually enumerate all valuations.
We added the function `erase` to convert `yes`, resp., `no`, to `tt`, resp., `ff`,
thus discarding the proof of correctness returned by `Tautology?`.)

### Entailment and equivalence

We say that a formula `œÜ` *entails* (or *logically implies*) a formula `œà`,
written `œÜ ‚áõ œà`, if every valuation that satisfies `œÜ` satisfies `œà` as well,
and that they are *logically equivalent*, written `œÜ ‚ü∫ œà`,
if they satisfy the same valuations:

```
infix 9 _‚áõ_ _‚ü∫_

_‚áõ_ : Formula ‚Üí Formula ‚Üí Set
œÜ ‚áõ œà = ‚àÄ[ œ± ] (‚ü¶ œÜ ‚üß œ± ‚â° tt ‚Üí ‚ü¶ œà ‚üß œ± ‚â° tt)

_‚ü∫_ : Formula ‚Üí Formula ‚Üí Set
œÜ ‚ü∫ œà =  ‚àÄ[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â° ‚ü¶ œà ‚üß œ±
```

(Although typographically similar,
entailment `_‚áõ_` shoud not be confused with the formula implication constructor `_‚áí_ : Formula ‚Üí Formula ‚Üí Formula`;
the same warning applies to logical equivalence `_‚ü∫_` vs. the bi-implication constructor `_‚áî_`.)
For the same reasons as for tautology, entailment and equivalence are decidable:

```
_‚áõ?_ : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚áõ œà)
œÜ ‚áõ? œà = ‚àÄ?[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â°? tt ‚Üí? ‚ü¶ œà ‚üß œ± ‚â°? tt

_‚ü∫?_ : ‚àÄ œÜ œà ‚Üí Dec (œÜ ‚ü∫ œà)
œÜ ‚ü∫? œà = ‚àÄ?[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â°? ‚ü¶ œà ‚üß œ±
```

For instance, we can check that `` ` p‚ÇÄ `` entails `` ` p‚ÇÄ ‚à® ` p‚ÇÅ ``, but not `` ` p‚ÇÅ ``,
and that `` ` p‚ÇÄ ‚àß ` p‚ÇÅ `` is logically equivalent to `` ` p‚ÇÅ ‚àß ` p‚ÇÄ ``:

```
_ : n ‚â° 0 ‚Üí erase (` p‚ÇÄ ‚áõ? ` p‚ÇÄ ‚à® ` p‚ÇÅ) ‚â° tt
_ = Œª{refl ‚Üí refl}

_ : n ‚â° 0 ‚Üí erase (` p‚ÇÄ ‚áõ? ` p‚ÇÅ) ‚â° ff
_ = Œª{refl ‚Üí refl}

_ : n ‚â° 0 ‚Üí erase (` p‚ÇÄ ‚àß ` p‚ÇÅ ‚ü∫? ` p‚ÇÅ ‚àß ` p‚ÇÄ) ‚â° tt
_ = Œª{refl ‚Üí refl}
```

!exercise(#exercise:entailment-preorder)(Entailment is a preorder)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that the entailment relation is a preorder:

```
refl-‚áõ : ‚àÄ œÜ ‚Üí œÜ ‚áõ œÜ
trans-‚áõ : ‚àÄ œÜ œà Œæ ‚Üí œÜ ‚áõ œà ‚Üí œà ‚áõ Œæ ‚Üí œÜ ‚áõ Œæ
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
refl-‚áõ œÜ _ = id
trans-‚áõ _ _ _ œÜ‚ä®œà œà‚ä®Œæ œ± = œà‚ä®Œæ œ± ‚àò œÜ‚ä®œà œ±
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For instance, we can prove the double negation law with the method of truth tables:

```
doubleNegationLaw : ‚àÄ œÜ ‚Üí ¬¨ ¬¨ œÜ ‚ü∫ œÜ
doubleNegationLaw œÜ œ± with ‚ü¶ œÜ ‚üß œ±
... | tt = refl
... | ff = refl
```

!exercise(#exercise:common-equivalences)(Common equivalences)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the folowing equivalences.
*Hint:* Use the method of truth tables.

```
deMorganAnd : ‚àÄ œÜ œà ‚Üí ¬¨ (œÜ ‚àß œà) ‚ü∫ ¬¨ œÜ ‚à® ¬¨ œà
deMorganOr : ‚àÄ œÜ œà ‚Üí ¬¨ (œÜ ‚à® œà) ‚ü∫ ¬¨ œÜ ‚àß ¬¨ œà
deMorganOr-alt : ‚àÄ œÜ œà ‚Üí œÜ ‚à® œà ‚ü∫ ¬¨ (¬¨ œÜ ‚àß ¬¨ œà)
deMorganImplies : ‚àÄ œÜ œà ‚Üí ¬¨ (œÜ ‚áí œà) ‚ü∫ œÜ ‚àß ¬¨ œà
deMorganIff : ‚àÄ œÜ œà ‚Üí ¬¨ (œÜ ‚áî œà) ‚ü∫ ¬¨ œÜ ‚áî œà
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
deMorganAnd œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

deMorganOr œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

deMorganOr-alt œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

deMorganImplies œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl

deMorganIff œÜ œà œ± with ‚ü¶ œÜ ‚üß œ± | ‚ü¶ œà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Equivalence is a congruence

Logical equivalence is a *congruence*:
Replacing a formula with an equivalent one preserves the semantics.

```
congF : ‚àÄ œÜ œà Œæ p ‚Üí
  œÜ ‚ü∫ œà ‚Üí
  -----------------------------
  Œæ F[ p ‚Ü¶ œÜ ] ‚ü∫ Œæ F[ p ‚Ü¶ œà ]
```

This is proved with a straightforward structural induction:

```
congF _ _ ‚ä§ p œÜ‚ü∫œà œ± = refl

congF _ _ ‚ä• p œÜ‚ü∫œà œ± = refl

congF _ _ (` q) p œÜ‚ü∫œà œ±
  with p ‚â°? q
... | yes = œÜ‚ü∫œà œ±
... | no = refl

congF œÜ œà (¬¨ Œæ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ p œÜ‚ü∫œà œ±
... | ind rewrite ind = refl

congF œÜ œà (Œæ‚ÇÄ ‚àß Œæ‚ÇÅ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ‚ÇÄ p œÜ‚ü∫œà œ± |
       congF œÜ œà Œæ‚ÇÅ p œÜ‚ü∫œà œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

congF œÜ œà (Œæ‚ÇÄ ‚à® Œæ‚ÇÅ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ‚ÇÄ p œÜ‚ü∫œà œ± |
       congF œÜ œà Œæ‚ÇÅ p œÜ‚ü∫œà œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

congF œÜ œà (Œæ‚ÇÄ ‚áí Œæ‚ÇÅ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ‚ÇÄ p œÜ‚ü∫œà œ± |
       congF œÜ œà Œæ‚ÇÅ p œÜ‚ü∫œà œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

congF œÜ œà (Œæ‚ÇÄ ‚áî Œæ‚ÇÅ) p œÜ‚ü∫œà œ±
  with congF œÜ œà Œæ‚ÇÄ p œÜ‚ü∫œà œ± |
       congF œÜ œà Œæ‚ÇÅ p œÜ‚ü∫œà œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl
```

!exercise(#exercise:cong2F)
~~~~~~~~~~~~~~~~~~~~~~~~~~

Show that replacing *two* formulas with two equivalent ones in parallel respects the semantics:

```
cong2F : ‚àÄ œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ p‚ÇÄ p‚ÇÅ ‚Üí
  œÜ‚ÇÄ ‚ü∫ œà‚ÇÄ ‚Üí
  œÜ‚ÇÅ ‚ü∫ œà‚ÇÅ ‚Üí
  -----------------------------------------------------
  Œæ F2[ p‚ÇÄ , p‚ÇÅ ‚Ü¶ œÜ‚ÇÄ , œÜ‚ÇÅ ] ‚ü∫ Œæ F2[ p‚ÇÄ , p‚ÇÅ ‚Ü¶ œà‚ÇÄ , œà‚ÇÅ ]
```
~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~
```
cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ ‚ä• p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ ‚ä§ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (` p) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with p‚ÇÄ ‚â°? p
... | yes = œÜ‚ÇÄ‚ü∫œà‚ÇÄ œ±
... | no
  with p‚ÇÅ ‚â°? p
... | yes = œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | no = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (¬¨ Œæ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind rewrite ind = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (Œæ‚ÇÄ ‚àß Œæ‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÄ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± |
       cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÅ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (Œæ‚ÇÄ ‚à® Œæ‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÄ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± |
       cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÅ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (Œæ‚ÇÄ ‚áí Œæ‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÄ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± |
       cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÅ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl

cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ (Œæ‚ÇÄ ‚áî Œæ‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
  with cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÄ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ± |
       cong2F œÜ‚ÇÄ œÜ‚ÇÅ œà‚ÇÄ œà‚ÇÅ Œæ‚ÇÅ p‚ÇÄ p‚ÇÅ œÜ‚ÇÄ‚ü∫œà‚ÇÄ œÜ‚ÇÅ‚ü∫œà‚ÇÅ œ±
... | ind‚ÇÄ | ind‚ÇÅ rewrite ind‚ÇÄ | ind‚ÇÅ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~

## Satisfiability

A formula `œÜ` is *satisfiable* if there exists some valuation satisfying it:

```
Sat : Formula ‚Üí Set
Sat œÜ = ‚àÉ[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â° tt
```

Satisfiability is decidable since we can enumerate satisfying assignments:

```
Sat? : ‚àÄ œÜ ‚Üí Dec (Sat œÜ)
Sat? œÜ = ‚àÉ?[ œ± ] ‚ü¶ œÜ ‚üß œ± ‚â°? tt
```

For instance, the formula `` ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ `` is satisfiable,
however `` ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÄ `` is not:

```
_ : n ‚â° 0 ‚Üí erase (Sat? (` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ)) ‚â° tt
_ = Œª{refl ‚Üí refl}

_ : n ‚â° 0 ‚Üí erase (Sat? (` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÄ)) ‚â° ff
_ = Œª{refl ‚Üí refl}
```

!exercise(#exercise:tau-sat)(Tautology and satisfiability)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Elaborate and prove a natural property connecting whether `œÜ` is a tautology and satisfiability.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
tau-sat : ‚àÄ œÜ ‚Üí Tautology œÜ ‚Üî ~ Sat (¬¨ œÜ)
tau-sat œÜ = tau‚Üísat , sat‚Üítau where

  tau‚Üísat : Tautology œÜ ‚Üí ~ Sat (¬¨ œÜ)
  tau‚Üísat tauœÜ (œ± , ‚ü¶¬¨œÜ‚üßœ±‚â°tt)
    with inspect (‚ü¶ œÜ ‚üß œ±)
  ... | it tt ‚ü¶œÜ‚üßœ±‚â°tt rewrite ‚ü¶œÜ‚üßœ±‚â°tt = ff‚â¢tt ‚ü¶¬¨œÜ‚üßœ±‚â°tt
  ... | it ff ‚ü¶œÜ‚üßœ±‚â°ff = ff‚â¢tt (trans (sym ‚ü¶œÜ‚üßœ±‚â°ff) (tauœÜ œ±))
  
  sat‚Üítau : ~ Sat (¬¨ œÜ) ‚Üí Tautology œÜ
  sat‚Üítau ~Sat¬¨œÜ œ±
    with inspect (‚ü¶ œÜ ‚üß œ±)
  ... | it tt ‚ü¶œÜ‚üßœ±‚â°tt = ‚ü¶œÜ‚üßœ±‚â°tt
  ... | it ff ‚ü¶œÜ‚üßœ±‚â°ff = F-elim (~Sat¬¨œÜ (œ± , ¬¨ùîπ‚ü¶œÜ‚üßœ±‚â°tt)) where

    ¬¨ùîπ‚ü¶œÜ‚üßœ±‚â°tt : ¬¨ùîπ ‚ü¶ œÜ ‚üß œ± ‚â° tt
    ¬¨ùîπ‚ü¶œÜ‚üßœ±‚â°tt rewrite ‚ü¶œÜ‚üßœ±‚â°ff = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Long conjunctions and disjunctions

### Conjunctions

Sometimes it is useful to interpret a list of formulas as their conjunction.
This is achieved with the following "long conjunction" operation:

```
infix 10 ‚ãÄ_
‚ãÄ_ : Formula * ‚Üí Formula
‚ãÄ œÜs = foldr _‚àß_ ‚ä§ œÜs
```

(Despite the typographical similarity,
`‚ãÄ` is a unary function mapping lists of formulas to their logical conjunction,
while `_‚àß_ : Formula ‚Üí Formula ‚Üí Formula` is a binary formula constructor.)
For instance, we have

```
_ : ‚ãÄ [ (` p‚ÇÄ) (` p‚ÇÅ) (` p‚ÇÇ) ] ‚â° ` p‚ÇÄ ‚àß ` p‚ÇÅ ‚àß ` p‚ÇÇ ‚àß ‚ä§
_ = refl
```

The following are the two defining properties of long conjunctions:

```
conjProp1 : ‚àÄ œÜs œ± ‚Üí
  ‚ü¶ ‚ãÄ œÜs ‚üß œ± ‚â° tt ‚Üí
  ------------------------
  ‚àÄ[ œÜ ‚àà œÜs ] ‚ü¶ œÜ ‚üß œ± ‚â° tt

conjProp2 : ‚àÄ œÜs œ± ‚Üí
  ‚àÄ[ œÜ ‚àà œÜs ] ‚ü¶ œÜ ‚üß œ± ‚â° tt ‚Üí
  ---------------
  ‚ü¶ ‚ãÄ œÜs ‚üß œ± ‚â° tt
```

!exercise(#exercise:long-conjunctions)(Long conjunctions)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the two defining properties `conjProp1` and `conjProp2` of long conjunctions
*Hint:* Use the corresponding properties for Booleans.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
conjProp1 _ œ± ‚ü¶œÜs‚üß‚â°tt here = ùîπconjProp1 _ _ ‚ü¶œÜs‚üß‚â°tt
conjProp1 (œà ‚à∑ œÜs) œ± ‚ü¶œà‚àßœÜs‚üß‚â°tt {œÜ} (there œÜ‚ààœÜs) = conjProp1 œÜs œ± (ùîπconjProp2 (‚ü¶ œà ‚üß œ±) _ ‚ü¶œà‚àßœÜs‚üß‚â°tt) œÜ‚ààœÜs

conjProp2 Œµ œ± ass = refl
conjProp2 (œÜ ‚à∑ œÜs) œ± ass = ùîπconjProp3 _ _ ‚ü¶œÜ‚üßœ±‚â°tt ‚ü¶‚ãÄœÜs‚üßœ±‚â°tt where

  ‚ü¶œÜ‚üßœ±‚â°tt : ‚ü¶ œÜ ‚üß œ± ‚â° tt
  ‚ü¶œÜ‚üßœ±‚â°tt = ass here

  ‚ü¶‚ãÄœÜs‚üßœ±‚â°tt : ‚ü¶ ‚ãÄ œÜs ‚üß œ± ‚â° tt
  ‚ü¶‚ãÄœÜs‚üßœ±‚â°tt = conjProp2 œÜs œ± Œª œà‚ààœÜs ‚Üí ass (there œà‚ààœÜs)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Disjunctions

We can also take "long disjunctions" of a sequence of formulas.
The corresponding two defining properties are dual to those of long conjunctions.

```
infix 9 ‚ãÅ_
‚ãÅ_ : Formula * ‚Üí Formula
‚ãÅ œÜs = foldr _‚à®_ ‚ä• œÜs

disjProp-tt : ‚àÄ œÜs œ± œÜ ‚Üí
  œÜ ‚àà œÜs ‚Üí
  ‚ü¶ œÜ ‚üß œ± ‚â° tt ‚Üí
  ---------------
  ‚ü¶ ‚ãÅ œÜs ‚üß œ± ‚â° tt

disjProp-ff : ‚àÄ œÜs œ± ‚Üí
  ‚àÄ[ œÜ ‚àà œÜs ] ‚ü¶ œÜ ‚üß œ± ‚â° ff ‚Üí
  ---------------
  ‚ü¶ ‚ãÅ œÜs ‚üß œ± ‚â° ff
```

!exercise(#exercise:long-disjunctions)(Long disjunctions) 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the two defining properties `disjProp-tt` and `disjProp-ff` above.
*Hint:* Use the corresponding properties for Booleans.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
disjProp-tt (œÜ ‚à∑ _) œ± œÜ here ‚ü¶œÜ‚üßœ±‚â°tt rewrite ‚ü¶œÜ‚üßœ±‚â°tt = refl
disjProp-tt (œà ‚à∑ _) œ± œÜ (there œÜ‚ààœÜs) ‚ü¶œÜ‚üßœ±‚â°tt
  with disjProp-tt _ œ± œÜ œÜ‚ààœÜs ‚ü¶œÜ‚üßœ±‚â°tt
... | ind = ùîπdisjProp2 (‚ü¶ œà ‚üß œ±) _ ind

disjProp-ff Œµ œ± ass = refl
disjProp-ff (œÜ ‚à∑ œÜs) œ± ass
  with disjProp-ff œÜs œ± Œª œà‚ààœÜs ‚Üí ass (there œà‚ààœÜs)
... | ind = ùîπdisjProp3 _ _ (ass here) ind
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Semantic deduction theorem

### Contexts

A *context* is a list of formulas.
The empty context will be denoted by `‚àÖ`.

```
Context = Formula *

‚àÖ : Context
‚àÖ = Œµ
```

If `Œì` is a context and `œÜ` is a formula,
we can add `œÜ` to `Œì` and form the new context `Œì ¬∑ œÜ`
(this is just adding an element on a list but written on the right).

```
infixl 50 _¬∑_  
_¬∑_ : Context ‚Üí Formula ‚Üí Context
Œì ¬∑ œÜ = œÜ ‚à∑ Œì
```

We say that a context `Œì` *entails* (or *logically implies*) a formula `œà`
if every valuation that satisfies every formula in `Œì`
satisfies `œà` as well:

```
infix 9 _‚ä®_
_‚ä®_ : Context ‚Üí Formula ‚Üí Set
Œì ‚ä® œà = ‚àÄ œ± ‚Üí All (Œª œÜ ‚Üí ‚ü¶ œÜ ‚üß œ± ‚â° tt) Œì ‚Üí ‚ü¶ œà ‚üß œ± ‚â° tt
```

!exercise(#exercise:commutative-context)(Commutativity of context)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Show that the order of the formulas in the context does not matter w.r.t. the satisfaction relation:

```
perm-sat : ‚àÄ {Œì Œî œ±} ‚Üí
  Perm Œì Œî ‚Üí
  All (Œª œÜ ‚Üí ‚ü¶ œÜ ‚üß œ± ‚â° tt) Œì ‚Üí
  --------------------------
  All (Œª œÜ ‚Üí ‚ü¶ œÜ ‚üß œ± ‚â° tt) Œî
```

*Hint*: Proceed by structural induction on permutations.
Deduce that the logical consequence relation is invariant under context permutation:

```
perm-‚ä® : ‚àÄ {Œì Œî} œÜ ‚Üí
  Perm Œì Œî ‚Üí
  Œì ‚ä® œÜ ‚Üí
  -----
  Œî ‚ä® œÜ
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
perm-sat stop AllŒì {œÜ} œÜ‚ààŒî = AllŒì œÜ‚ààŒî

perm-sat {œà ‚à∑ Œì} {œà ‚à∑ Œî} (skip perm) AllŒì {œà} here = AllŒì here
perm-sat {œà ‚à∑ Œì} {œà ‚à∑ Œî} (skip perm) AllŒì {œÜ} (there œÜ‚ààŒî)
  = perm-sat {Œì} {Œî} perm (Œª {Œæ} Œæ‚ààŒì ‚Üí AllŒì (there Œæ‚ààŒì)) œÜ‚ààŒî
  
perm-sat (swap perm) AllŒì {_} here = AllŒì (there here)
perm-sat (swap perm) AllŒì {_} (there here) = AllŒì here
perm-sat {œÜ ‚à∑ œà ‚à∑ Œì} {œà ‚à∑ œÜ ‚à∑ Œî} (swap perm) AllŒì {Œæ} (there (there Œæ‚ààŒî))
  = perm-sat perm (AllŒì ‚àò there ‚àò there) Œæ‚ààŒî 

perm-sat {Œì} {Œî} (tran {bs = Œû} perm1 perm2) AllŒì
  with perm-sat perm1 AllŒì
... | AllŒû = perm-sat perm2 AllŒû
                            
perm-‚ä® œÜ perm Œì‚ä®œÜ œ± AllŒî = Œì‚ä®œÜ œ± (perm-sat (perm-sym perm) AllŒî)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:context-alt)(Alternative definition of entailment)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
An alternative definition of entailment `Œì ‚ä® œÜ` between a context and a formula
could be based on the previous definition of entailment `œà ‚áõ œÜ` between two formulas:

```
_‚ä®‚Ä≤_ : Context ‚Üí Formula ‚Üí Set
Œì ‚ä®‚Ä≤ œÜ = ‚ãÄ Œì ‚áõ œÜ
```

Show that the two notions of entailment are equivalent:

```
context1 : ‚àÄ {Œì} œÜ ‚Üí
  Œì ‚ä® œÜ ‚Üí
  ------
  Œì ‚ä®‚Ä≤ œÜ
  
context2 : ‚àÄ Œì {œÜ} ‚Üí
  Œì ‚ä®‚Ä≤ œÜ ‚Üí
  -----
  Œì ‚ä® œÜ
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
context1 {Œì} œÜ Œì‚ä®œÜ œ± ‚ü¶‚ãÄŒì‚üßœ±‚â°tt = Œì‚ä®œÜ œ± (conjProp1 Œì œ± ‚ü¶‚ãÄŒì‚üßœ±‚â°tt)
context2 Œì {œÜ} ‚ãÄŒì‚áõœÜ œ± AllŒì = ‚ãÄŒì‚áõœÜ œ± (conjProp2 Œì œ± AllŒì)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Deduction theorem

The semantic deduction theorem establishes a close connection between the implication connective `_‚áí_`,
which is a syntactic object,
and entailment `_‚ä®_`, which is a semantic one.
It consists of two halves.
The first half shows how to move a formula from the context to the right of `_‚ä®_`:

```
semDT1 : ‚àÄ Œì œÜ œà ‚Üí
  Œì ¬∑ œÜ ‚ä® œà ‚Üí
  ----------
  Œì ‚ä® œÜ ‚áí œà
```

The second half shows the converse operation:

```
semDT2 : ‚àÄ Œì œÜ œà ‚Üí
  Œì ‚ä® œÜ ‚áí œà ‚Üí
  ---------
  Œì ¬∑ œÜ ‚ä® œà
```

!exercise(#exercise:sem-DT)(Semantic deduction theorem)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove the two parts `semDT1` and `semDT2` of the semantic deduction theorem.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
semDT1 Œì œà œÜ Œì¬∑œà‚ä®œÜ = Œî‚ä®œà‚áíœÜ where

  Œî‚ä®œà‚áíœÜ : Œì ‚ä® œà ‚áí œÜ
  Œî‚ä®œà‚áíœÜ œ± ‚ü¶Œì‚üß with inspect (‚ü¶ œà ‚üß œ±)
  ... | it ff ‚ü¶œà‚üßœ±‚â°ff = ùîπimplProp1 _ _ ‚ü¶œà‚üßœ±‚â°ff
  ... | it tt ‚ü¶œà‚üßœ±‚â°tt rewrite ‚ü¶œà‚üßœ±‚â°tt = trans eql ‚ü¶œÜ‚üßœ±‚â°tt where

    eql : tt ‚áíùîπ ‚ü¶ œÜ ‚üß œ± ‚â° ‚ü¶ œÜ ‚üß œ±
    eql = ùîπimplProp2 _ _ refl
    
    ‚ü¶œÜ‚üßœ±‚â°tt : ‚ü¶ œÜ ‚üß œ± ‚â° tt
    ‚ü¶œÜ‚üßœ±‚â°tt = Œì¬∑œà‚ä®œÜ œ± ‚ü¶œà‚à∑Œì‚üß where

      ‚ü¶œà‚à∑Œì‚üß : ‚àÄ[ Œæ ‚àà œà ‚à∑ Œì ] ‚ü¶ Œæ ‚üß œ± ‚â° tt
      ‚ü¶œà‚à∑Œì‚üß here = ‚ü¶œà‚üßœ±‚â°tt
      ‚ü¶œà‚à∑Œì‚üß (there Œæ‚ààŒì) = ‚ü¶Œì‚üß Œæ‚ààŒì

semDT2 Œì œÜ œà Œì‚ä®œÜ‚áíœà œ± AllŒì¬∑œÜ = ‚ü¶œà‚üßœ±‚â°tt where

  AllŒì : All (Œª œÜ ‚Üí ‚ü¶ œÜ ‚üß œ± ‚â° tt) Œì
  AllŒì {œÜ} œÜ‚ààŒì = AllŒì¬∑œÜ (there œÜ‚ààŒì)

  ‚ü¶œÜ‚üßœ±‚â°tt : ‚ü¶ œÜ ‚üß œ± ‚â° tt
  ‚ü¶œÜ‚üßœ±‚â°tt = AllŒì¬∑œÜ here
  
  ‚ü¶œà‚üßœ±‚â°tt : ‚ü¶ œà ‚üß œ± ‚â° tt
  ‚ü¶œà‚üßœ±‚â°tt rewrite sym (ùîπimplProp2 _ (‚ü¶ œà ‚üß œ±) ‚ü¶œÜ‚üßœ±‚â°tt) = Œì‚ä®œÜ‚áíœà œ± AllŒì 
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By repeated application of the semantic deduction theorem,
we can in fact move all formulas from one side to the other.
First, we define "long implications":

```
infix 10 _Imply_
_Imply_ : Formula * ‚Üí Formula ‚Üí Formula
Œµ Imply œÜ = œÜ
(œà ‚à∑ Œî) Imply œÜ = Œî Imply (œà ‚áí œÜ)
```

For instance,

```
_ : ‚àÖ ¬∑ œÜ‚ÇÄ ¬∑ œÜ‚ÇÅ Imply ` p‚ÇÄ ‚â° œÜ‚ÇÄ ‚áí œÜ‚ÇÅ ‚áí ` p‚ÇÄ
_ = refl
```

We can now state and prove the following "long" versions of the semantic deduction theorem.

```
longSemDT1 : ‚àÄ Œî œÜ ‚Üí
  Œî ‚ä® œÜ ‚Üí
  -------------
  ‚àÖ ‚ä® Œî Imply œÜ
  
longSemDT1 Œµ œÜ Œµ‚ä®œÜ = Œµ‚ä®œÜ
longSemDT1 (œà ‚à∑ Œî) œÜ œà‚à∑Œî‚ä®œÜ = longSemDT1 Œî (œà ‚áí œÜ) (semDT1 Œî œà œÜ œà‚à∑Œî‚ä®œÜ)

longSemDT2 : ‚àÄ Œî œÜ ‚Üí
  ‚àÖ ‚ä® Œî Imply œÜ ‚Üí
  -----
  Œî ‚ä® œÜ
  
longSemDT2 Œµ œÜ ‚àÖ‚ä®œÜ œ± All‚àÖ = ‚àÖ‚ä®œÜ œ± All‚àÖ
longSemDT2 (œà ‚à∑ Œî) œÜ ‚àÖ‚ä®ŒîImplyœÜ = semDT2 Œî œà œÜ (longSemDT2 Œî (œà ‚áí œÜ) ‚àÖ‚ä®ŒîImplyœÜ)
```

# Formula simplification

```
simplify : Formula ‚Üí Formula
simplify (‚ä• ‚àß œÜ) = ‚ä•
simplify (œÜ ‚àß ‚ä•) = ‚ä•
simplify (‚ä§ ‚àß œÜ) = simplify œÜ
simplify (œÜ ‚àß ‚ä§) = simplify œÜ
simplify (‚ä• ‚à® œÜ) = simplify œÜ
simplify (œÜ ‚à® ‚ä•) = simplify œÜ
simplify (‚ä§ ‚à® œÜ) = ‚ä§
simplify (œÜ ‚à® ‚ä§) = ‚ä§
simplify (¬¨ œÜ) = ¬¨ simplify œÜ
simplify (œÜ ‚àß œà) = simplify œÜ ‚àß simplify œà
simplify (œÜ ‚à® œà) = simplify œÜ ‚à® simplify œà
simplify œÜ = œÜ
```

# Characteristic formulas {#characteristic-formulas}

Let `œ±` be a valuation and `œÜ` a formula.
We say that `œÜ` is a *characteristic formula* for `œ±`,
written `œÜ CharFormulaOf œ±` if

1) `œ±` satisfies `œÜ`, and
2)  no other valuation satisfies `œÜ`.

Formally, we have the following definition:

```
_CharFormulaOf_ : Formula ‚Üí Val ‚Üí Set
œÜ CharFormulaOf œ± = ‚ü¶ œÜ ‚üß œ± ‚â° tt √ó ‚àÄ œ±‚Ä≤ ‚Üí ‚ü¶ œÜ ‚üß œ±‚Ä≤ ‚â° tt ‚Üí œ±‚Ä≤ ‚â° œ±
```

!example(#example:characteristic-formula)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For instance, consider the valuation

```
œ±‚ÇÅ = const tt [ p‚ÇÄ ‚Ü¶ ff ] [ p‚ÇÅ ‚Ü¶ ff ]
```

that assigns value `tt` to every proposition,
except for `p‚ÇÄ` and `p‚ÇÅ`.
Under the assumption that there are only three propositions `p‚ÇÄ, p‚ÇÅ, p‚ÇÇ` in the universe,
a characteristic formula for `œ±‚ÇÅ` is, e.g.,

```
œà‚ÇÅ = ¬¨ ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ ‚àß ` p‚ÇÇ
```

In order to show `œà‚ÇÅ CharFormulaOf œ±‚ÇÅ`, we use appropriate Boolean inversion properties
to enforce that every valuation `œ±‚Ä≤` satisfying `œà‚ÇÅ`
necessarily assigns `ff` to `p‚ÇÄ, p‚ÇÅ`, and `tt` to `p‚ÇÇ`.
We then use function extensionality to conclude `œ±‚Ä≤ ‚â° œ±‚ÇÅ`, as required:

```
œà‚ÇÅCharFormulaOfœ±‚ÇÅ : n ‚â° 0 ‚Üí œà‚ÇÅ CharFormulaOf œ±‚ÇÅ
œà‚ÇÅCharFormulaOfœ±‚ÇÅ refl = refl , goal where

  goal : ‚àÄ œ±‚Ä≤ ‚Üí ‚ü¶ œà‚ÇÅ ‚üß œ±‚Ä≤ ‚â° tt ‚Üí œ±‚Ä≤ ‚â° œ±‚ÇÅ
  goal œ±‚Ä≤ eval
    with ùîπconjProp1 (‚ü¶ ¬¨ ` p‚ÇÄ ‚üß œ±‚Ä≤) _ eval |
         ùîπconjProp1 (‚ü¶ ¬¨ ` p‚ÇÅ ‚üß œ±‚Ä≤) _ (ùîπconjProp2 (‚ü¶ ¬¨ ` p‚ÇÄ ‚üß œ±‚Ä≤) _ eval) |
         ùîπconjProp2 (‚ü¶ ¬¨ ` p‚ÇÅ ‚üß œ±‚Ä≤) _ (ùîπconjProp2 (‚ü¶ ¬¨ ` p‚ÇÄ ‚üß œ±‚Ä≤) _ eval)
  ... | eval1 | eval2 | eval3
    with ¬¨ùîπ-inv _ eval1 |
         ¬¨ùîπ-inv _ eval2
  ... | eval1' | eval2' = extensionality go where

    go : ‚àÄ[ p ] œ±‚Ä≤ p ‚â° œ±‚ÇÅ p
    go fzero rewrite eval1' = refl
    go (fsuc fzero) rewrite eval2' = refl
    go (fsuc (fsuc fzero)) rewrite eval3 = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A characteristic formula puts sufficiently many constraints on its satisfying valuations
as to identify a unique satisfying valuation.
Thus, characteristic formulas, which are a syntactic object,
are in bijection with valuations (modulo logical equivalence), which are a semantic object.

!exercise(#exercise:charFormulaUnique)(Uniqueness of characteristic formulas)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that characteristic formulas of a given valuation are unique,
up to logical equivalence:

```
charFormulaUnique : ‚àÄ œÜ œà œ± ‚Üí
  œÜ CharFormulaOf œ± ‚Üí
  œà CharFormulaOf œ± ‚Üí
  -----
  œÜ ‚áõ œà
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
charFormulaUnique œÜ œà œ± (_ , œÜCFœ±) (‚ü¶œà‚üßœ±‚â°tt , _) œ±‚Ä≤ ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt = ‚ü¶œà‚üßœ±‚Ä≤‚â°tt where

  œ±‚Ä≤‚â°œ± : œ±‚Ä≤ ‚â° œ±
  œ±‚Ä≤‚â°œ± = œÜCFœ± œ±‚Ä≤ ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt

  ‚ü¶œà‚üßœ±‚Ä≤‚â°tt : ‚ü¶ œà ‚üß œ±‚Ä≤ ‚â° tt
  ‚ü¶œà‚üßœ±‚Ä≤‚â°tt rewrite œ±‚Ä≤‚â°œ± = ‚ü¶œà‚üßœ±‚â°tt
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that we have a notion of characteristic formula,
the next question is whether, given a valuation,
we can construct a characteristic formula for it.
This is the content of the rest of this section.

## Literals

We being by considering single propositional variables.
Given a valuation `œ±`, we transform a propositional variable `p`
into a corresponding *characteristic literal* `„Äå p „Äç œ±` depending on whether `œ± p` is true or false:

```
„Äå_„Äç_ : PropName ‚Üí Val ‚Üí Formula
„Äå p „Äç œ± with œ± p
... | tt = ` p
... | ff = ¬¨ ` p
```

In the first case (i.e., if `œ± p` is `tt`)
we say that the characteristic literal of `„Äå p „Äç œ±` is *positive*,
and in the other case that it is *negative*.
There are two fundamental properties satisfied by `„Äå p „Äç œ±`.
The first is *soundness*: `„Äå p „Äç œ±` is satisfied by `œ±`:

```
charLit-sound : ‚àÄ œ± p ‚Üí
  -------------------
  ‚ü¶ „Äå p „Äç œ± ‚üß œ± ‚â° tt

charLit-sound œ± p with inspect (œ± p)
... | it tt œ±p‚â°tt rewrite œ±p‚â°tt | œ±p‚â°tt = refl
... | it ff œ±p‚â°ff rewrite œ±p‚â°ff | œ±p‚â°ff = refl
```

(Notice that we need to rewrite twice in each case.
For example in the first case we need to rewrite twice accoriding to the same equality `œ±p‚â°tt : œ± p ‚â° tt`:
The first rewrite transforms `‚ü¶ „Äå p „Äç œ± ‚üß œ±` into ``‚ü¶ ` p ‚üß œ±``,
and the second rewrite transforms the latter into `tt`, as required.
A single rewrite does not suffice.
For this reason, the simpler solution

    charLit-sound œ± p with œ± p
    ... | tt = refl
    ... | it = refl

only achieves the effect of rewriting once and does not work.)
The second fundamental property of `„Äå p „Äç œ±` is *completeness*:
For every other valuation `œ±‚Ä≤` which also satisfies `„Äå p „Äç œ±`,
it must be the case that `œ±` and `œ±‚Ä≤` agree on `p`:

```
charLit-complete : ‚àÄ œ± p œ±‚Ä≤ ‚Üí
  ‚ü¶ „Äå p „Äç œ± ‚üß œ±‚Ä≤ ‚â° tt ‚Üí
  ----------
  œ±‚Ä≤ p ‚â° œ± p
  
charLit-complete œ± p œ±‚Ä≤ ‚ü¶„Äåp„Äçœ±‚üßœ±‚Ä≤‚â°tt
  with œ± p
... | tt = ‚ü¶„Äåp„Äçœ±‚üßœ±‚Ä≤‚â°tt
... | ff with œ±‚Ä≤ p
... | tt = sym ‚ü¶„Äåp„Äçœ±‚üßœ±‚Ä≤‚â°tt
... | ff = refl
```

!example(#example:char-lit)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For example, we can compute a positive and a negative characteristic literal of `œ±‚ÇÄ`:

```
_ : „Äå p‚ÇÄ „Äç œ±‚ÇÄ  ‚â° ¬¨ ` p‚ÇÄ
_ = refl

_ : „Äå p‚ÇÇ „Äç œ±‚ÇÄ  ‚â° ` p‚ÇÇ
_ = refl
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Formulas

We can now compute the (a) characteristic formula `„Äî œ± „Äï` of a valuation `œ±`.
The idea is to compute the characteristic literal of every proposition
and then to conjoin all those characteristic literals with a long conjunction:

```
„Äî_„Äï : Val ‚Üí Formula
„Äî œ± „Äï = ‚ãÄ literals module CharFormula where

  literals : Formula *
  literals = map („Äå_„Äç œ±) propNames
```

(Note how we create a local module named `CharFormula` inside the definition of `„Äî_„Äï`.
This will allow us to reuse the definition of `literals` when proving the correctness of the construction.)
Incidentally, we note that characteristic formulas are conjunctive formulas,
i.e., the only logical connectives are `‚àß` and `¬¨`.

!example(#example:char-lit)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For example, we can compute the characteristic formula of `œ±‚ÇÄ`
(automatically, this time):

```
_ : n ‚â° 0 ‚Üí „Äî œ±‚ÇÄ „Äï ‚â° ¬¨ ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ ‚àß ` p‚ÇÇ ‚àß ‚ä§
_ = Œª{refl ‚Üí refl}
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Like characteristic literals,
also the construction of characteristic formulas must satisfy the properties of soundness and completeness
in order to be considered correct.
Soundness says that the valuation `œ±` satisfies its own characteristic formula `„Äî œ± „Äï`:

```
charFormula-sound : ‚àÄ œ± ‚Üí
  ------------------
  ‚ü¶ „Äî œ± „Äï ‚üß œ± ‚â° tt
  
charFormula-sound œ±  = conjProp2 literals œ± go where

  open CharFormula œ±

  go : ‚àÄ[ œÜ ‚àà literals ] ‚ü¶ œÜ ‚üß œ± ‚â° tt
  go {œÜ} œÜ‚ààliterals
    with map-‚àà-inv („Äå_„Äç œ±) œÜ‚ààliterals
  ... | p , _ , œÜ‚â°„Äåp„Äçœ± = ‚ü¶œÜ‚üßœ±‚â°tt where

    ‚ü¶„Äåp„Äçœ±‚üßœ±‚â°tt : ‚ü¶ „Äå p „Äç œ± ‚üß œ± ‚â° tt
    ‚ü¶„Äåp„Äçœ±‚üßœ±‚â°tt = charLit-sound œ± p

    ‚ü¶œÜ‚üßœ±‚â°tt : ‚ü¶ œÜ ‚üß œ± ‚â° tt
    ‚ü¶œÜ‚üßœ±‚â°tt rewrite œÜ‚â°„Äåp„Äçœ± | ‚ü¶„Äåp„Äçœ±‚üßœ±‚â°tt = refl
```

Notice how we open the local module `CharFormula` in order to use the definition of `literals` from `„Äî_„Äï`.
Completeness says that, if any valuation `œ±‚Ä≤` satisfies the characteristic formula `„Äî œ± „Äï` of a valuation `œ±`,
then `œ±‚Ä≤ ‚â° œ±`.

```
charFormula-complete : ‚àÄ œ± œ±‚Ä≤ ‚Üí
  ‚ü¶ „Äî œ± „Äï ‚üß œ±‚Ä≤ ‚â° tt ‚Üí
  -----------------
  œ±‚Ä≤ ‚â° œ±
  
charFormula-complete œ± œ±‚Ä≤ ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt = extensionality go where

  go : ‚àÄ[ p ] œ±‚Ä≤ p ‚â° œ± p
  go p = charLit-complete œ± p œ±‚Ä≤ (conjProp1 literals œ±‚Ä≤ ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt ‚ààliterals) where

    open CharFormula œ±

    ‚ààliterals : „Äå p „Äç œ± ‚àà literals
    ‚ààliterals = map-‚àà („Äå_„Äç œ±) (find p)
```

Soundness and completeness taken together ensure that `„Äî œ± „Äï` is a characteristic formula of `œ±`:

!theorem(#theorem:char-formula)(Characteristic formulas)
~~~~~~~~~~
For every valuation `œ±` there exists a characteristic formula `„Äî œ± „Äï` thereof:

```
thCharFormula : ‚àÄ œ± ‚Üí
  -----------------------
  „Äî œ± „Äï CharFormulaOf œ±
  
thCharFormula œ± = charFormula-sound œ± , charFormula-complete œ±
```
~~~~~~~~~~

Characteristic formulas will be instrumental in the next section in order to show that propositional formulas are functionally complete, in the sense that every Boolean function can be represented as the semantics of a propositional formula.

# Functional completeness {#Functional-Completeness}

The type of the semantic function is `‚ü¶_‚üß_ : Formula ‚Üí Val ‚Üí ùîπ`.
Once we fix a formula `œÜ`, it becomes `‚ü¶ œÜ ‚üß_ : Val ‚Üí ùîπ`,
which is the type of a *Boolean function*, i.e.,
a mapping that takes in input a valuation `Val`
and produces a Boolean value `ùîπ`:

```
ùîπFun = Val ‚Üí ùîπ
```

The question arises whether every Boolean function can be represented as the semantics `‚ü¶ œÜ ‚üß_`
of some propositional formula `œÜ`.
We will see shortly that this is the case.
We will also be interested to put restrictions on the connectives that we are allowed to use in order to build `œÜ`.
A set of connectives is *functionally complete*
if any Boolean function can be expressed by a formula using only connectives in the set:

```
FunctionallyComplete : (Fragment : Formula ‚Üí Set) ‚Üí Set
FunctionallyComplete Fragment = ‚àÄ[ f ] ‚àÉ[ œÜ ] (Fragment œÜ √ó ‚ü¶ œÜ ‚üß_ ‚â° f)
```

In this section we explore which set of connectives is functionally complete.

## Fragment `{‚à®, ‚àß, ¬¨, ‚ä§, ‚ä•}`

We consider the fragment consisting only of conjunction, disjunction, negation, true, and false.
Thus, w.r.t. the full syntax of propositional formulas,
we do not allow either implication `‚áí`, or bi-implication `‚áî`.
Formally, this fragment is defined as the following inductive datatype:
   
```
data Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] : Formula ‚Üí Set where
  ‚ä• : Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] ‚ä•
  ‚ä§ : Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] ‚ä§
  `_ : ‚àÄ p ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (` p)
  ¬¨_ : ‚àÄ {œÜ} ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (¬¨ œÜ)
  _‚àß_ : ‚àÄ {œÜ œà} ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œà ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (œÜ ‚àß œà)
  _‚à®_ : ‚àÄ {œÜ œà} ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œà ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (œÜ ‚à® œà)
```

In the following, fix an arbitrary Boolean function `f : ùîπFun`.
We want to build a formula `œÜ` in the fragment whose semantics equals that of `f`:

```
funCompl[‚ä•,‚ä§,¬¨,‚à®,‚àß] : FunctionallyComplete Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]
```

We will achieve this in three steps:

1) We build the formula `œÜ` corresponding to `f`.
2) We show that `œÜ` is in the fragment.
3) We show that the formula `œÜ` is indeed equivalent to `f`.

*Step 1*. The construction of the formula is based on the characteristic formulas from the previous section.
Namely, we consider all valuations `œ±` s.t. `f œ± ‚â° tt` and we take the disjunction of their characteristic formulas:

```
fun‚Üíformula : ùîπFun ‚Üí Formula
fun‚Üíformula f = ‚ãÅ œÜs module ùîπFun‚ÜíFormula where

  ttVals = filter (Œª œ± ‚Üí f œ± ‚â°? tt) vals
  œÜs = map „Äî_„Äï ttVals
```

(We give a module name `ùîπFun‚ÜíFormula` in the internal declarations of `ttVals` and `œÜs` above
in order to be able to reuse them later on.

!example(#example-fun2formula)
~~~~~~~~~~~~~~~~~~~~~~~~~
For instance, consider the following Boolean function that returns true iff all its inputs are equal,
and false otherwise:

```
f‚ÇÄ : ùîπFun
f‚ÇÄ œ± = foldr (Œª b‚ÇÄ b‚ÇÅ ‚Üí b‚ÇÅ ‚àßùîπ erase (b‚ÇÄ ‚â°? œ± p‚ÇÄ)) tt (map œ± propNames)
```

We can construct the corresponding formula in the special case of three propositional variables
(the application of !ref(simplify) removes some redundant !ref(Formula)(‚ä§) and !ref(Formula)(‚ä•) constants):

```
_ : n ‚â° 0 ‚Üí simplify (fun‚Üíformula f‚ÇÄ) ‚â°
  ` p‚ÇÄ ‚àß ` p‚ÇÅ ‚àß ` p‚ÇÇ ‚à®
    ¬¨ ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ ‚àß ¬¨ ` p‚ÇÇ
_ = Œª{ refl ‚Üí refl}
```
~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:fun2formula)(The xor function)
~~~~~~~~~~~~~~~~~~~~~~~~~~
Define the Boolean function that computes the exclusive-or (xor) of its inputs
and compute the corresponding formula with the help of `fun‚Üíformula`.
~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~
```
xor : ùîπFun
xor œ± = foldr (Œª b‚ÇÄ b‚ÇÅ ‚Üí erase (b‚ÇÄ ‚â°? b‚ÇÅ)) (œ± p‚ÇÄ) (tail (map œ± propNames))

_ : n ‚â° 0 ‚Üí simplify (fun‚Üíformula xor) ‚â°
  ` p‚ÇÄ ‚àß ` p‚ÇÅ ‚àß ` p‚ÇÇ ‚à®
    ¬¨ ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ ‚àß ` p‚ÇÇ ‚à®
      ¬¨ ` p‚ÇÄ ‚àß ` p‚ÇÅ ‚àß ¬¨ ` p‚ÇÇ ‚à®
        ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÅ ‚àß ¬¨ ` p‚ÇÇ
_ = Œª{refl ‚Üí refl}
```
~~~~~~~~~~~~~~~~~~~~~~~~~~

*Step 2*. In the second step we show that !ref(fun‚Üíformula) outputs a formula in the !ref(Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]) fragment.
In fact, it more natural to show the stronger fact that the !ref(Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]) fragment is closed under long conjunctions and disjunctions:

```
Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÄ-closed : ‚àÄ œÜs ‚Üí All Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜs ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (‚ãÄ œÜs)
Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÄ-closed Œµ all = ‚ä§
Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÄ-closed (œÜ ‚à∑ œÜs) all
  with Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÄ-closed œÜs (Œª œÜ‚ààœÜs ‚Üí all (there œÜ‚ààœÜs))
... | ind = all here ‚àß ind

Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÅ-closed : ‚àÄ œÜs ‚Üí All Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜs ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (‚ãÅ œÜs)
Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÅ-closed Œµ all = ‚ä•
Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÅ-closed (œÜ ‚à∑ œÜs) all
  with Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÅ-closed œÜs (Œª œÜ‚ààœÜs ‚Üí all (there œÜ‚ààœÜs))
... | ind = all here ‚à® ind
```

Characteristic literals obviously are in the fragment:

```
charLit-fragment : ‚àÄ œ± p ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] („Äå p „Äç œ± )
charLit-fragment œ± p with œ± p
... | tt = ` p
... | ff = ¬¨ ` p
```

Characteristic formulas are in the fragment,
thanks to closure under long conjunctions:

```
charFormula-fragment : ‚àÄ œ± ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] „Äî œ± „Äï
charFormula-fragment œ± = Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÄ-closed literals all where

  open CharFormula œ±

  all : All Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] literals
  all œÜ‚ààliterals
    with map-‚àà-inv _ œÜ‚ààliterals
  ... | p , _ , œÜ‚â°„Äåp„Äçœ± rewrite œÜ‚â°„Äåp„Äçœ± = charLit-fragment œ± p
```

Finally, also `fun‚Üíformula f` is in the fragment,
thanks to closure under long disjunctions:

```
‚ààfragment : ‚àÄ f ‚Üí Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] (fun‚Üíformula f)
‚ààfragment f = Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÅ-closed œÜs all where

  open ùîπFun‚ÜíFormula f

  all : All Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜs
  all œà‚ààœÜs
    with map-‚àà-inv _ œà‚ààœÜs
  ... | œ± , _ , œà‚â°„Äîœ±„Äï rewrite œà‚â°„Äîœ±„Äï = charFormula-fragment œ±
```

*Step 3*. In the last step, we show that !ref(fun‚Üíformula) produces a formula which is equivalent to the input Boolean function.
The proof is based on both soundness and completeness of characteristic formulas `„Äî œ± „Äï`.

```
fun‚Üíformula-correct : ‚àÄ f ‚Üí ‚àÄ[ œ± ] ‚ü¶ fun‚Üíformula f ‚üß œ± ‚â° f œ±
fun‚Üíformula-correct f œ± with inspect (f œ±)
```

We perform a case analysis on `f œ±`.
If `f` evaluates to true on `œ±`,
then we need to show that `fun‚Üíformula f` also evaluates to true:

```
... | it tt fœ±‚â°tt rewrite fœ±‚â°tt = goal where

  open ùîπFun‚ÜíFormula f

  goal : ‚ü¶ fun‚Üíformula f ‚üß œ± ‚â° tt
```

We begin by finding the occurrence `findVal œ±` of `œ±` in the list of all valuations !ref(vals) and then, knowing that `f œ±` evaluates to `tt` by assumption,
we find a witness `œ±‚ààttVals` that `œ±` belongs to !ref(ùîπFun‚ÜíFormula)(ttVals):

```
  goal
    with filter-‚àà (findVal œ±) fœ±‚â°tt
  ... | œ±‚ààttVals
```

Thus, by the definition of !ref(ùîπFun‚ÜíFormula)(œÜs),
we have `„Äî œ± „Äï ‚àà œÜs`:

```
    with map-‚àà _ œ±‚ààttVals
  ... | „Äîœ±„Äï‚ààœÜs
```

By soundness of characteristic formulas,
we have `‚ü¶ „Äî œ± „Äï ‚üß œ± ‚â° tt`:

```
    with charFormula-sound œ±
  ... | ‚ü¶„Äîœ±„Äï‚üßœ±‚â°tt = disjProp-tt œÜs œ± „Äî œ± „Äï „Äîœ±„Äï‚ààœÜs ‚ü¶„Äîœ±„Äï‚üßœ±‚â°tt
```

The proof ends by !ref(disjProp-tt) since we found a disjunct `„Äî œ± „Äï` that evaluates to true.

In the second case, `f` evaluates to false on `œ±`,
and thus we must show the same for `fun‚Üíformula f `.
In order to achieve this, we use again the disjunction property,
which requires us to prove that all disjuncts in !ref(ùîπFun‚ÜíFormula)(œÜs) evaluate to false:

```
... | it ff fœ±‚â°ff rewrite fœ±‚â°ff = disjProp-ff œÜs œ± goal where

  open ùîπFun‚ÜíFormula f
  
  goal : ‚àÄ[ œÜ ‚àà œÜs ] ‚ü¶ œÜ ‚üß œ± ‚â° ff
```

We thus consider an arbitrary `œÜ` in !ref(ùîπFun‚ÜíFormula)(œÜs) and do a case analysis on its value under `œ±`.
If it evaluates to false, then we are done:

```
  goal {œÜ} œÜ‚ààœÜs
    with inspect (‚ü¶ œÜ ‚üß œ±)
  ... | it ff ‚ü¶œÜ‚üßœ±‚â°ff = ‚ü¶œÜ‚üßœ±‚â°ff
```

Otherwise, `œÜ` evaluates to true, and we look for a contradiction.
First of all, since `œÜ` is a disjunct in !ref(ùîπFun‚ÜíFormula)(œÜs),
by definition it is the characteristic formula of some valuation `œ±‚Ä≤` in !ref(ùîπFun‚ÜíFormula)(ttVals):

```
  ... | it tt ‚ü¶œÜ‚üßœ±‚â°tt
    with map-‚àà-inv „Äî_„Äï œÜ‚ààœÜs
  ... | œ±‚Ä≤ , œ±‚Ä≤‚ààttVals , œÜ‚â°„Äîœ±‚Ä≤„Äï 
```

By definition, !ref(ùîπFun‚ÜíFormula)(ttVals) is the list of those valuations `œ±` s.t. `f œ±` is true.
Since `œ±‚Ä≤` is one of those, `f œ±‚Ä≤` must be true:

```
    with filter-‚àà-inv vals œ±‚Ä≤‚ààttVals 
  ... | œ±‚Ä≤‚ààvals , fœ±‚Ä≤‚â°tt
```

We would like to deduce that `œ±` is equal to `œ±‚Ä≤` by completeness of characteristic formulas.
In order to apply !ref(„Äî „Äï-complete), we need to show `‚ü¶ „Äî œ±‚Ä≤ „Äï ‚üß œ± ‚â° tt`.
But this is certainly true, since `‚ü¶ œÜ ‚üß œ± ‚â° tt` by assumption,
and `œÜ ‚â° „Äî œ±‚Ä≤ „Äï` by the definition of `œ±‚Ä≤`:

```
    rewrite œÜ‚â°„Äîœ±‚Ä≤„Äï
    with charFormula-complete œ±‚Ä≤ œ± ‚ü¶œÜ‚üßœ±‚â°tt
  ... | œ±‚â°œ±‚Ä≤
```

We can now reach the sought contradiction since `f œ±‚Ä≤ ‚â° tt` and `f œ± ‚â° ff` at the same time:

```
    rewrite œ±‚â°œ±‚Ä≤ = a‚â°ff‚Üía‚â°tt-elim fœ±‚â°ff fœ±‚Ä≤‚â°tt
```

This concludes the second and last  case of the correctness proof.
We can put all the pieces together and show that the fragment is functionally complete.

!theorem(#theorem:funComplFalseTrueNegAndOr)(Functional completeness of `{‚à®, ‚àß, ¬¨, ‚ä§, ‚ä•}`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
funCompl[‚ä•,‚ä§,¬¨,‚à®,‚àß] f =
  fun‚Üíformula f , ‚ààfragment f , extensionality (fun‚Üíformula-correct f)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Fragment `{‚à®, ‚àß, ¬¨}`

Let's restrict our previous fragment !ref(Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]) by forbidding the constants !ref(Formula)(‚ä•) and !ref(Formula)(‚ä§).
Formally, we have the following definition:

```
data Formula[¬¨‚à®‚àß] : Formula ‚Üí Set where
  `_ : ‚àÄ p ‚Üí Formula[¬¨‚à®‚àß] (` p)
  ¬¨_ : ‚àÄ {œÜ} ‚Üí Formula[¬¨‚à®‚àß] œÜ ‚Üí Formula[¬¨‚à®‚àß] (¬¨ œÜ)
  _‚àß_ : ‚àÄ {œÜ œà} ‚Üí Formula[¬¨‚à®‚àß] œÜ ‚Üí Formula[¬¨‚à®‚àß] œà ‚Üí Formula[¬¨‚à®‚àß] (œÜ ‚àß œà)
  _‚à®_ : ‚àÄ {œÜ œà} ‚Üí Formula[¬¨‚à®‚àß] œÜ ‚Üí Formula[¬¨‚à®‚àß] œà ‚Üí Formula[¬¨‚à®‚àß] (œÜ ‚à® œà)
```

We show that this fragment is functionally complete:

```
funCompl[¬¨‚à®‚àß] : FunctionallyComplete Formula[¬¨‚à®‚àß]
```

Thanks to the fact that !ref(Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]) is functionally complete (c.f. !ref(funCompl[‚ä•,‚ä§,¬¨,‚à®,‚àß]))
it suffices to remove the two logical constants `‚ä•` and `‚ä§`:

```
remove‚ä•‚ä§ : ‚àÄ {œÜ} ‚Üí
  Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß] œÜ ‚Üí
  -------------------------------
  ‚àÉ[ œà ] Formula[¬¨‚à®‚àß] œà √ó œÜ ‚ü∫ œà
```

In order to do so, we need to have at least one propositional variable `p‚ÇÄ` at our disposal
(which is indeed the case).
We replace `‚ä•` with `` ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÄ``
and `‚ä§` with `` ` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÄ``,
using the fact that we have at least one proposition `p‚ÇÄ`:

```
remove‚ä•‚ä§ {‚ä•} ‚ä• = _ , ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÄ , ‚ä•‚ü∫p‚ÇÄ‚àß¬¨p‚ÇÄ where

  ‚ä•‚ü∫p‚ÇÄ‚àß¬¨p‚ÇÄ : ‚ä• ‚ü∫ ` p‚ÇÄ ‚àß ¬¨ ` p‚ÇÄ
  ‚ä•‚ü∫p‚ÇÄ‚àß¬¨p‚ÇÄ œ± with œ± p‚ÇÄ
  ... | tt = refl
  ... | ff = refl

remove‚ä•‚ä§ {‚ä§} ‚ä§ = _ , ` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÄ , ‚ä§‚ü∫p‚ÇÄ‚à®¬¨p‚ÇÄ where

  ‚ä§‚ü∫p‚ÇÄ‚à®¬¨p‚ÇÄ : ‚ä§ ‚ü∫ ` p‚ÇÄ ‚à® ¬¨ ` p‚ÇÄ
  ‚ä§‚ü∫p‚ÇÄ‚à®¬¨p‚ÇÄ œ± with œ± p‚ÇÄ
  ... | tt = refl
  ... | ff = refl
```

The variable case is straightforward:

```
remove‚ä•‚ä§ {` p} (` p) = ` p , ` p , Œª œ± ‚Üí refl
```

The inductive cases are also rather easy.
We recursively compute the inductive assumption
and then we use the two congruence lemmas !ref(congF) and !ref(cong2F) in order to show correctness:

```
remove‚ä•‚ä§ {¬¨ œÜ} (¬¨ F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œÜ)
  with remove‚ä•‚ä§ F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œÜ
... | œà , F[¬¨‚à®‚àß]œà , œÜ‚ü∫œà = ¬¨ œà , ¬¨ F[¬¨‚à®‚àß]œà , congF œÜ œà (¬¨ ` p‚ÇÄ) p‚ÇÄ œÜ‚ü∫œà

remove‚ä•‚ä§ {œÜ ‚àß œà} (F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œÜ ‚àß F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œà)
  with remove‚ä•‚ä§ {œÜ} F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œÜ |
       remove‚ä•‚ä§ {œà} F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œà
... | œÜ‚Ä≤ , F[¬¨‚à®‚àß]œÜ‚Ä≤ , œÜ‚ü∫œÜ‚Ä≤
    | œà‚Ä≤ , F[¬¨‚à®‚àß]œà‚Ä≤ , œà‚ü∫œà‚Ä≤ =
      œÜ‚Ä≤ ‚àß œà‚Ä≤ , F[¬¨‚à®‚àß]œÜ‚Ä≤ ‚àß F[¬¨‚à®‚àß]œà‚Ä≤ , cong2F œÜ œà œÜ‚Ä≤ œà‚Ä≤ (` p‚ÇÄ ‚àß ` p‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ü∫œÜ‚Ä≤ œà‚ü∫œà‚Ä≤ 

remove‚ä•‚ä§ {œÜ ‚à® œà} (F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œÜ ‚à® F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œà)
  with remove‚ä•‚ä§ {œÜ} F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œÜ |
       remove‚ä•‚ä§ {œà} F[‚ä•,‚ä§,¬¨,‚à®,‚àß]œà
... | œÜ‚Ä≤ , F[¬¨‚à®‚àß]œÜ‚Ä≤ , œÜ‚ü∫œÜ‚Ä≤
    | œà‚Ä≤ , F[¬¨‚à®‚àß]œà‚Ä≤ , œà‚ü∫œà‚Ä≤ =
      œÜ‚Ä≤ ‚à® œà‚Ä≤ , F[¬¨‚à®‚àß]œÜ‚Ä≤ ‚à® F[¬¨‚à®‚àß]œà‚Ä≤ , cong2F œÜ œà œÜ‚Ä≤ œà‚Ä≤ (` p‚ÇÄ ‚à® ` p‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ü∫œÜ‚Ä≤ œà‚ü∫œà‚Ä≤ 
```

With !ref(remove‚ä•‚ä§) in hand, it is easy to prove functional completeness of this fragment:

```
funCompl[¬¨‚à®‚àß] f
  with funCompl[‚ä•,‚ä§,¬¨,‚à®,‚àß] f
... | œÜ , Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]œÜ , ‚ü¶œÜ‚üß‚â°f
  with remove‚ä•‚ä§ Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]œÜ
... | œà , Formula[¬¨‚à®‚àß]œà , œÜ‚ü∫œà rewrite sym ‚ü¶œÜ‚üß‚â°f
  = œà , Formula[¬¨‚à®‚àß]œà , sym (extensionality œÜ‚ü∫œà) 
```

!exercise(#exercise:removeTrueFalse-alt)
~~~~~~~~~~~~~~~~~~~~~~~~~~~
We have seen that one way to remove the constants !ref(Formula)(‚ä§) and !ref(Formula)(‚ä•) is to convert them "locally" to simple tautologies, resp., absurdities, involving a fixed propositional variable.
This style of solution will be useful in !refSection(#sec:FragmentsAndNeg).
Are there alternative ways to achieve the same effect?
~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Certainly there are. One possibility is to repeatedly apply !ref(simplify) until no more constants appear in the formula.
The tricky part is to encode this in such a way as to convince the termination checker.
Note that each application of !ref(simplify) either leaves the formula unaltered
or it strictly decreases its size.
Based on this observation, one could define a repeated application of !ref(simplify) by well-founded recursion on the size of formulas.
We omit the details here, but we will see definitions by well-founded recursion in the [NormalForms](/part1/NormalForms/) chapter.
~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Fragments `{‚àß, ¬¨}` and `{‚à®, ¬¨}` {#sec:FragmentsAndNeg}

We further restrict the syntax by additionally forbidding disjunction `‚à®`:

```
data Formula[¬¨‚àß] : Formula ‚Üí Set where
  `_ : ‚àÄ p ‚Üí Formula[¬¨‚àß] (` p)
  ¬¨_ : ‚àÄ {œÜ} ‚Üí Formula[¬¨‚àß] œÜ ‚Üí Formula[¬¨‚àß] (¬¨ œÜ)
  _‚àß_ : ‚àÄ {œÜ œà} ‚Üí Formula[¬¨‚àß] œÜ ‚Üí Formula[¬¨‚àß] œà ‚Üí Formula[¬¨‚àß] (œÜ ‚àß œà)
```

Since the fragments `{‚àß, ¬¨}` and `{‚à®, ¬¨}` are dual to each other,
we focus on the former.

!exercise(#exercise:FormulaNegAnd)(Functional completeness of `{‚àß, ¬¨}`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Show that !ref(Formula[¬¨‚àß]) is functionally complete:

```
funCompl[¬¨‚àß] : FunctionallyComplete Formula[¬¨‚àß]
```

*Hint*: Use functional completeness of !ref(Formula[¬¨‚à®‚àß]), as proved in !ref(funCompl[¬¨‚à®‚àß]),
and use de Morgan's law to express disjunction `‚à®` in terms of conjunction `‚àß` and negation `¬¨`.
~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~
We start with an auxiliary procedure doing the heavy lifting of removing disjunction:

```
remove‚à® : ‚àÄ {œÜ} ‚Üí
  Formula[¬¨‚à®‚àß] œÜ ‚Üí
  ------------------------------
  ‚àÉ[ œà ] Formula[¬¨‚àß] œà √ó œÜ ‚ü∫ œà
```

The variable case, negation, and conjunction are straightforward:

```
remove‚à® {` p} (` p) = ` p , ` p , Œª œ± ‚Üí refl

remove‚à® {¬¨ œÜ} (¬¨ F[¬¨‚à®‚àß]œÜ)
  with remove‚à® F[¬¨‚à®‚àß]œÜ
... | œà , F[¬¨‚àß]œà , œÜ‚ü∫œà = ¬¨ œà , ¬¨ F[¬¨‚àß]œà , congF œÜ œà (¬¨ ` p‚ÇÄ) p‚ÇÄ œÜ‚ü∫œà

remove‚à® {œÜ ‚àß œà} (F[¬¨‚à®‚àß]œÜ ‚àß F[¬¨‚à®‚àß]œà)
  with remove‚à® {œÜ} F[¬¨‚à®‚àß]œÜ |
       remove‚à® {œà} F[¬¨‚à®‚àß]œà
... | œÜ‚Ä≤ , F[¬¨‚àß]œÜ‚Ä≤ , œÜ‚ü∫œÜ‚Ä≤
    | œà‚Ä≤ , F[¬¨‚àß]œà‚Ä≤ , œà‚ü∫œà‚Ä≤ =
      œÜ‚Ä≤ ‚àß œà‚Ä≤ , F[¬¨‚àß]œÜ‚Ä≤ ‚àß F[¬¨‚àß]œà‚Ä≤ , cong2F œÜ œà œÜ‚Ä≤ œà‚Ä≤ (` p‚ÇÄ ‚àß ` p‚ÇÅ) p‚ÇÄ p‚ÇÅ œÜ‚ü∫œÜ‚Ä≤ œà‚ü∫œà‚Ä≤ 
```

The only non-trivial case is the one for disjunction.
Here, we remove it thanks to de Morgan's law:

```
remove‚à® {œÜ ‚à® œà} (F[¬¨‚à®‚àß]œÜ ‚à® F[¬¨‚à®‚àß]œà)
  with remove‚à® {œÜ} F[¬¨‚à®‚àß]œÜ |
       remove‚à® {œà} F[¬¨‚à®‚àß]œà
... | œÜ‚Ä≤ , F[¬¨‚àß]œÜ‚Ä≤ , œÜ‚ü∫œÜ‚Ä≤
    | œà‚Ä≤ , F[¬¨‚àß]œà‚Ä≤ , œà‚ü∫œà‚Ä≤ =
      ¬¨ (¬¨ œÜ‚Ä≤ ‚àß ¬¨ œà‚Ä≤) , ¬¨ (¬¨ F[¬¨‚àß]œÜ‚Ä≤ ‚àß ¬¨ F[¬¨‚àß]œà‚Ä≤) , goal where

    goal : ‚àÄ[ œ± ] ‚ü¶ œÜ ‚à® œà ‚üß œ± ‚â° ‚ü¶ ¬¨ (¬¨ œÜ‚Ä≤ ‚àß ¬¨ œà‚Ä≤) ‚üß œ±
    goal œ± rewrite œÜ‚ü∫œÜ‚Ä≤ œ± | œà‚ü∫œà‚Ä≤ œ± = deMorganOr-alt œÜ‚Ä≤ œà‚Ä≤ œ±
```

With !ref(remove‚à®) in hand, it is immediate to conclude the proof of functional completeness:

```
funCompl[¬¨‚àß] f
  with funCompl[¬¨‚à®‚àß] f
... | œÜ , Formula[¬¨‚à®‚àß]œÜ , ‚ü¶œÜ‚üß‚â°f
  with remove‚à® {œÜ} Formula[¬¨‚à®‚àß]œÜ
... | œà , Formula[¬¨‚àß]œà , œÜ‚ü∫œà rewrite ‚ü¶œÜ‚üß‚â°f
  = œà , Formula[¬¨‚àß]œà , sym (extensionality œÜ‚ü∫œà)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Fragment `{‚áí, ‚ä•}`

We now consider yet another fragment, where we only allow implication and the false constant:

```
data Formula[‚áí,‚ä•] : Formula ‚Üí Set where
  ‚ä• : Formula[‚áí,‚ä•] ‚ä•
  `_ : ‚àÄ p ‚Üí Formula[‚áí,‚ä•] (` p)
  _‚áí_ : ‚àÄ {œÜ œà} ‚Üí Formula[‚áí,‚ä•] œÜ ‚Üí Formula[‚áí,‚ä•] œà ‚Üí Formula[‚áí,‚ä•] (œÜ ‚áí œà)
```

!exercise(#exercise:FormulaImplFalse)(Functional completeness of `{‚áí, ‚ä•}`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Show that !ref(Formula[‚áí,‚ä•]) is functionally complete:

```
funCompl[‚áí,‚ä•] : FunctionallyComplete Formula[‚áí,‚ä•]
```

*Hint*: Find a way express conjunction and negation in terms of implication `‚áí`.
~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
convert[¬¨,‚àß]‚Üí[‚áí,‚ä•] : ‚àÄ {œÜ} ‚Üí
  Formula[¬¨‚àß] œÜ ‚Üí
  -------------------------------
  ‚àÉ[ œà ] Formula[‚áí,‚ä•] œà √ó œÜ ‚ü∫ œà

convert[¬¨,‚àß]‚Üí[‚áí,‚ä•] {` p} (` p) = ` p , ` p , Œª œ± ‚Üí refl

convert[¬¨,‚àß]‚Üí[‚áí,‚ä•] {¬¨ œÜ} (¬¨ F[¬¨‚àß]œÜ)
  with convert[¬¨,‚àß]‚Üí[‚áí,‚ä•] F[¬¨‚àß]œÜ
... | œà , F[¬¨‚àß]œà , œÜ‚ü∫œà =  œà ‚áí ‚ä• , F[¬¨‚àß]œà ‚áí ‚ä• , ¬¨œÜ‚ü∫œà‚áí‚ä• where

  ¬¨œÜ‚ü∫œà‚áí‚ä• : ¬¨ œÜ ‚ü∫ œà ‚áí ‚ä•
  ¬¨œÜ‚ü∫œà‚áí‚ä• œ± rewrite œÜ‚ü∫œà œ±
    with ‚ü¶ œà ‚üß œ±
  ... | tt = refl
  ... | ff = refl

convert[¬¨,‚àß]‚Üí[‚áí,‚ä•] {œÜ ‚àß œà} (F[¬¨‚àß]œÜ ‚àß F[¬¨‚àß]œà)
  with convert[¬¨,‚àß]‚Üí[‚áí,‚ä•] {œÜ} F[¬¨‚àß]œÜ |
       convert[¬¨,‚àß]‚Üí[‚áí,‚ä•] {œà} F[¬¨‚àß]œà
... | œÜ‚Ä≤ , F[¬¨‚àß]œÜ‚Ä≤ , œÜ‚ü∫œÜ‚Ä≤
    | œà‚Ä≤ , F[¬¨‚àß]œà‚Ä≤ , œà‚ü∫œà‚Ä≤ =
       (œÜ‚Ä≤ ‚áí (œà‚Ä≤ ‚áí ‚ä•)) ‚áí ‚ä• , (F[¬¨‚àß]œÜ‚Ä≤ ‚áí F[¬¨‚àß]œà‚Ä≤ ‚áí ‚ä•) ‚áí ‚ä• , goal where

    goal : œÜ ‚àß œà ‚ü∫ (œÜ‚Ä≤ ‚áí œà‚Ä≤ ‚áí ‚ä•) ‚áí ‚ä•
    goal œ± rewrite œÜ‚ü∫œÜ‚Ä≤ œ± | œà‚ü∫œà‚Ä≤ œ±
      with ‚ü¶ œÜ‚Ä≤ ‚üß œ± | ‚ü¶ œà‚Ä≤ ‚üß œ±
    ... | tt | tt = refl
    ... | tt | ff = refl
    ... | ff | tt = refl
    ... | ff | ff = refl
```

```
funCompl[‚áí,‚ä•] f
  with funCompl[¬¨‚àß] f
... | œÜ , Formula[¬¨‚àß]œÜ , ‚ü¶œÜ‚üß‚â°f
  with convert[¬¨,‚àß]‚Üí[‚áí,‚ä•] {œÜ} Formula[¬¨‚àß]œÜ
... | œà , Formula[‚áí,‚ä•]œà , œÜ‚ü∫œà rewrite ‚ü¶œÜ‚üß‚â°f
  = œà , Formula[‚áí,‚ä•]œà , sym (extensionality œÜ‚ü∫œà)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Fragment `{‚ä•, ‚ä§, ‚à®, ‚àß}`

In this section we explore the fragment where we only allow conjunction and disjunction,
i.e., no negation, implication, or bi-implication:

```
data Formula[‚ä•,‚ä§,‚à®,‚àß] : Formula ‚Üí Set where
  ‚ä• : Formula[‚ä•,‚ä§,‚à®,‚àß] ‚ä•
  ‚ä§ : Formula[‚ä•,‚ä§,‚à®,‚àß] ‚ä§
  `_ : ‚àÄ p ‚Üí Formula[‚ä•,‚ä§,‚à®,‚àß] (` p)
  _‚àß_ : ‚àÄ {œÜ œà} ‚Üí Formula[‚ä•,‚ä§,‚à®,‚àß] œÜ ‚Üí Formula[‚ä•,‚ä§,‚à®,‚àß] œà ‚Üí Formula[‚ä•,‚ä§,‚à®,‚àß] (œÜ ‚àß œà)
  _‚à®_ : ‚àÄ {œÜ œà} ‚Üí Formula[‚ä•,‚ä§,‚à®,‚àß] œÜ ‚Üí Formula[‚ä•,‚ä§,‚à®,‚àß] œà ‚Üí Formula[‚ä•,‚ä§,‚à®,‚àß] (œÜ ‚à® œà)
```

As a preparation for the following,
we prove that this fragment is closed under long intersections and disjunctions:

```
Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÄ-closed : ‚àÄ œÜs ‚Üí
  All Formula[‚ä•,‚ä§,‚à®,‚àß] œÜs ‚Üí
  -----------------------
  Formula[‚ä•,‚ä§,‚à®,‚àß] (‚ãÄ œÜs)
  
Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÅ-closed : ‚àÄ œÜs ‚Üí
  All Formula[‚ä•,‚ä§,‚à®,‚àß] œÜs ‚Üí
  -----------------------
  Formula[‚ä•,‚ä§,‚à®,‚àß] (‚ãÅ œÜs)
```

<!-- *Hint*: C.f. !ref(Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÄ-closed) and !ref(Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚à®-closed). -->

!hide
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The two proofs are identical to !ref(Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚ãÄ-closed), resp., !ref(Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]-‚à®-closed).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÄ-closed Œµ all = ‚ä§
Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÄ-closed (œÜ ‚à∑ œÜs) all
  with Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÄ-closed œÜs (Œª œÜ‚ààœÜs ‚Üí all (there œÜ‚ààœÜs))
... | ind = all here ‚àß ind

Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÅ-closed Œµ all = ‚ä•
Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÅ-closed (œÜ ‚à∑ œÜs) all
  with Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÅ-closed œÜs (Œª œÜ‚ààœÜs ‚Üí all (there œÜ‚ààœÜs))
... | ind = all here ‚à® ind
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:fragmentAndOr)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Is this fragment semantically complete?
Find a Boolean function which cannot be expressed in the fragment.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This fragment is not complete w.r.t. all Boolean functions.
For example, the negation function (say of the first variable) cannot be expressed:

```
f¬¨ : ùîπFun
f¬¨ œ± = ¬¨ùîπ œ± p‚ÇÄ
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first observation is that this fragment can only encode monotone Boolean functions.
(We have here in mind the natural ordering `ff ‚â§ùîπ tt` on `ùîπ`.)
Intuitively, a Boolean function is monotone iff flipping one input from `ff` to `tt` can only increase the output.
Formally, we define a partial order `_‚â§V_` on valuation by lifting `_‚â§ùîπ_` point-wise in the expected way:

```
_‚â§V_ : Val ‚Üí Val ‚Üí Set
œ± ‚â§V œ±‚Ä≤ = ‚àÄ[ p ] œ± p ‚â§ùîπ œ±‚Ä≤ p
```

which allows us to define what it means for a Boolean function to be monotone:

```
Monotone : ùîπFun ‚Üí Set
Monotone f = ‚àÄ œ± œ±‚Ä≤ ‚Üí œ± ‚â§V œ±‚Ä≤ ‚Üí f œ± ‚â§ùîπ f œ±‚Ä≤
```

!exercise(#exercise:negNotMonotone)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Formally Prove that the counterexample you constructed in !refExercise(#exercise:fragmentAndOr) is not monotone.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Our counterexample !ref(f¬¨) is not monotone:

```
f¬¨-notMonotone : ~ Monotone f¬¨
f¬¨-notMonotone mon = ~tt‚â§ùîπff tt‚â§ff where

  œ±ff œ±tt : Val
  œ±ff = const ff
  œ±tt = const tt

  œ±ff‚â§œ±tt : œ±ff ‚â§V œ±tt
  œ±ff‚â§œ±tt p = ff‚â§tt

  tt‚â§ff : tt ‚â§ùîπ ff
  tt‚â§ff = mon œ±ff œ±tt œ±ff‚â§œ±tt
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:fragmentAndOrOnlyMonotone)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that the `{‚ä•, ‚ä§, ‚à®, ‚àß}` fragment can only represent monotone functions:

```
only-monotone : ‚àÄ {œÜ} ‚Üí Formula[‚ä•,‚ä§,‚à®,‚àß] œÜ ‚Üí Monotone ‚ü¶ œÜ ‚üß_
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The proof follows a straightforward structural induction.
The two constants case is immediate:

```
only-monotone ‚ä• _ _ _ = ff‚â§ff
only-monotone ‚ä§ _ _ _ = tt‚â§tt
```

In the variable case, we use the monotonicity assumption:

```
only-monotone (` p) Œ± Œ≤ Œ±‚â§Œ≤ = Œ±‚â§Œ≤ p
```

In the two inductive cases,
we use the monotonicity of the semantics of conjunction and disjunction:

```
only-monotone (viewœÜ ‚àß viewœà) Œ± Œ≤ Œ±‚â§Œ≤ with
  only-monotone viewœÜ Œ± Œ≤ Œ±‚â§Œ≤ |
  only-monotone viewœà Œ± Œ≤ Œ±‚â§Œ≤
... | ‚ü¶œÜ‚üßŒ±‚â§‚ü¶œÜ‚üßŒ≤ | ‚ü¶œà‚üßŒ±‚â§‚ü¶œà‚üßŒ≤ = monotone-‚àßùîπ ‚ü¶œÜ‚üßŒ±‚â§‚ü¶œÜ‚üßŒ≤ ‚ü¶œà‚üßŒ±‚â§‚ü¶œà‚üßŒ≤

only-monotone (viewœÜ ‚à® viewœà) Œ± Œ≤ Œ±‚â§Œ≤ with
  only-monotone viewœÜ Œ± Œ≤ Œ±‚â§Œ≤ |
  only-monotone viewœà Œ± Œ≤ Œ±‚â§Œ≤
... | ‚ü¶œÜ‚üßŒ±‚â§‚ü¶œÜ‚üßŒ≤ | ‚ü¶œà‚üßŒ±‚â§‚ü¶œà‚üßŒ≤ = monotone-‚à®ùîπ ‚ü¶œÜ‚üßŒ±‚â§‚ü¶œÜ‚üßŒ≤ ‚ü¶œà‚üßŒ±‚â§‚ü¶œà‚üßŒ≤
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This suggests that the `{‚ä•, ‚ä§, ‚à®, ‚àß}` fragment may be able to encode *all* monotone Boolean functions.
This is true and slightly harder to prove.

We begin by encoding of the single literals:

```
monCharLit : Val ‚Üí PropName ‚Üí Formula
monCharLit œ± p
  with œ± p
... | tt = ` p
... | ff = ‚ä§ -- !
```

The second case of the definition above may be surprising
since we are just ignoring the proposition `p` when the valuation `œ±` says false.
Monotonicity will ensure that this is the right definition.

!exercise(#exercise:monCharLit-Formula)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Formally prove that !ref(monCharLit) produces a formula in the fragment:

```
monCharLit-Formula[‚ä•,‚ä§,‚à®,‚àß] : ‚àÄ œ± p ‚Üí
  ---------------------------------
  Formula[‚ä•,‚ä§,‚à®,‚àß] (monCharLit œ± p)
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
monCharLit-Formula[‚ä•,‚ä§,‚à®,‚àß] œ± p
  with œ± p
... | tt = ` p
... | ff = ‚ä§
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!exercise(#exercise:monCharLit-sound-complete)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Prove that !ref(monCharLit) is sound and complete in the following sense:

```
monCharLit-soundness : ‚àÄ œ± p ‚Üí
  -----------------------
  ‚ü¶ monCharLit œ± p ‚üß œ± ‚â° tt

monCharLit-completeness : ‚àÄ œ± p œ±‚Ä≤ ‚Üí
  ‚ü¶ monCharLit œ± p ‚üß œ±‚Ä≤ ‚â° tt ‚Üí
  ------------
  œ± p ‚â§ùîπ œ±‚Ä≤ p
```

Notice that we just require the more relaxed `œ± p ‚â§ùîπ œ±‚Ä≤ p` in !ref(monCharLit-completeness),
instead of a full equality `œ± p ‚â° œ±‚Ä≤ p` as in !ref(charLit-completeness).
This is the correct choice since we will only be representing monotone Boolean functions.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
monCharLit-soundness œ± p
  with inspect (œ± p)
... | it tt eq rewrite eq | eq = refl 
... | it ff eq rewrite eq = refl
            
monCharLit-completeness œ± p œ±‚Ä≤ ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt
    with inspect (œ± p) | inspect (œ±‚Ä≤ p)
... | it tt eq | it tt eq‚Ä≤ rewrite ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt | eq | eq‚Ä≤ = tt‚â§tt
... | it ff eq | it tt eq‚Ä≤ rewrite ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt | eq | eq‚Ä≤ = ff‚â§tt
... | it tt eq | it ff eq‚Ä≤ rewrite ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt | eq | eq‚Ä≤ = ff‚â¢tt-elim ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt
... | it ff eq | it ff eq‚Ä≤ rewrite ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt | eq | eq‚Ä≤ = ff‚â§ff
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We now build monotone characteristic formulas,
following the same idea as in !ref(„Äî_„Äï)‚Äîbut of course replacing !ref(„Äå_„Äç_) with !ref(monCharLit):

```
monCharFormula : Val ‚Üí Formula
monCharFormula œ± = ‚ãÄ map (monCharLit œ±) propNames
```

!exercise(#exercise-monCharFormula)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Show that

1) monotone characteristic formulas belong to the fragment, c.f. !ref(charFormula-Formula[‚ä•,‚ä§,¬¨,‚à®,‚àß]),
2) they are sound, and
3) they are complete:

```
monCharFormula-Formula[‚ä•,‚ä§,‚à®,‚àß] : ‚àÄ œ± ‚Üí
  -----------------------------------
  Formula[‚ä•,‚ä§,‚à®,‚àß] (monCharFormula œ±)
```

```
monCharFormula-soundness : ‚àÄ œ± ‚Üí
  ---------------------------
  ‚ü¶ monCharFormula œ± ‚üß œ± ‚â° tt
```

```
monCharFormula-completeness : ‚àÄ œ± œ±‚Ä≤ ‚Üí
  ‚ü¶ monCharFormula œ± ‚üß œ±‚Ä≤ ‚â° tt ‚Üí
  ---------------------------
  œ± ‚â§V œ±‚Ä≤
```

Notice that completeness is weaker than the corresponding property in !ref(charFormula-complete),
since it demands only `œ± ‚â§V œ±‚Ä≤` instead of `œ± ‚â° œ±‚Ä≤`.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```
monCharFormula-Formula[‚ä•,‚ä§,‚à®,‚àß] œ± =
  Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÄ-closed (map (monCharLit œ±) propNames) all where

  all : All Formula[‚ä•,‚ä§,‚à®,‚àß] (map (monCharLit œ±) propNames)
  all œÜ‚ààmap
    with map-‚àà-inv _ œÜ‚ààmap
  ... | p , _ , œÜ‚â°monCharLitœ±p rewrite œÜ‚â°monCharLitœ±p = monCharLit-Formula[‚ä•,‚ä§,‚à®,‚àß] œ± p
```

Soundness and completeness of monotone characteristic formulas work as expected,
relying on the corresponding properties for literals:

```
monCharFormula-soundness œ± = conjProp2 (map (monCharLit œ±) propNames) œ± go where

    go : ‚àÄ[ œÜ ‚àà map (monCharLit œ±) propNames ] ‚ü¶ œÜ ‚üß œ± ‚â° tt
    go {œÜ} œÜ‚ààliterals
      with map-‚àà-inv (monCharLit œ±) œÜ‚ààliterals
    ... | p , p‚ààpropNames , œÜ‚â°monCharLitœ±p
      rewrite œÜ‚â°monCharLitœ±p | monCharLit-soundness œ± p = refl
```

```
monCharFormula-completeness œ± œ±‚Ä≤ ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt p
  with findPropName p
... | p‚ààpropNames
  with map-‚àà (monCharLit œ±) p‚ààpropNames
... | mCLœ±p‚ààmap
  with conjProp1 (map (monCharLit œ±) propNames) œ±‚Ä≤ ‚ü¶œÜ‚üßœ±‚Ä≤‚â°tt mCLœ±p‚ààmap
... | ‚ü¶mCLœ±p‚üßœ±‚Ä≤‚â°tt = monCharLit-completeness œ± p œ±‚Ä≤ ‚ü¶mCLœ±p‚üßœ±‚Ä≤‚â°tt
```
~~~~~~~~~~~~~~~~~~~~~~~~~~~~


With all these ingredients in hand,
we are now ready to prove that the `{‚ä•, ‚ä§, ‚à®, ‚àß}` fragment is functionally complete for monotone functions:

```
MonotoneFunctionallyComplete : (Formula ‚Üí Set) ‚Üí Set
MonotoneFunctionallyComplete Fragment =
  ‚àÄ f ‚Üí Monotone f ‚Üí ‚àÉ[ œÜ ] (Fragment œÜ √ó ‚ü¶ œÜ ‚üß_ ‚â° f)

monFunCompl[‚ä•,‚ä§,‚à®,‚àß] : MonotoneFunctionallyComplete Formula[‚ä•,‚ä§,‚à®,‚àß]

monFunCompl[‚ä•,‚ä§,‚à®,‚àß] f monf = œÜ , Formula[‚ä•,‚ä§,‚à®,‚àß]œÜ , extensionality correctness where
```

The construction of the formula `œÜ` expressing `f` is analogous to !ref(funCompl[‚ä•,‚ä§,¬¨,‚à®,‚àß]),
except that !ref(„Äî_„Äï) is replaced by !ref(monCharFormula):

```
  ttVals = filter (Œª œ± ‚Üí f œ± ‚â°? tt) vals
  œÜs = map monCharFormula ttVals
  œÜ = ‚ãÅ œÜs
```

The formula `œÜ` belongs to the fragment thanks to closure under disjunctions:

```
  Formula[‚ä•,‚ä§,‚à®,‚àß]œÜ : Formula[‚ä•,‚ä§,‚à®,‚àß] œÜ
  Formula[‚ä•,‚ä§,‚à®,‚àß]œÜ = Formula[‚ä•,‚ä§,‚à®,‚àß]-‚ãÅ-closed œÜs goal where

    goal : All Formula[‚ä•,‚ä§,‚à®,‚àß] œÜs
    goal œÜ‚ààœÜs
      with map-‚àà-inv _ œÜ‚ààœÜs
    ... | œ± , _ , œÜ‚â°monCharFormulaœ± rewrite œÜ‚â°monCharFormulaœ±
      = monCharFormula-Formula[‚ä•,‚ä§,‚à®,‚àß] œ±
```

Correctness consists into two parts.
The first part is easily proved by soundness:

```
  correctness : ‚àÄ œ± ‚Üí ‚ü¶ œÜ ‚üß œ± ‚â° f œ±
  correctness œ±
    with inspect (f œ±)
  ... | it tt fœ±‚â°tt rewrite fœ±‚â°tt = goal where

    goal : ‚ü¶ œÜ ‚üß œ± ‚â° tt
    goal
      with filter-‚àà (findVal œ±) fœ±‚â°tt
    ... | œ±‚ààttVals
      with map-‚àà monCharFormula œ±‚ààttVals
    ... | monCharFormulaœ±‚ààœÜs
      with monCharFormula-soundness œ±
    ... | ‚ü¶monCharFormulaœ±‚üßœ±‚â°tt
      = disjProp-tt œÜs œ± (monCharFormula œ±) monCharFormulaœ±‚ààœÜs ‚ü¶monCharFormulaœ±‚üßœ±‚â°tt 
```

For the second part, we aim at reaching a contradiction impinging on monotonicity:

```
  ... | it ff fœ±‚â°ff rewrite fœ±‚â°ff = disjProp-ff œÜs œ± goal where

    goal : ‚àÄ[ œÜ ‚àà œÜs ] ‚ü¶ œÜ ‚üß œ± ‚â° ff
    goal {œÜ} œÜ‚ààœÜs
       with inspect (‚ü¶ œÜ ‚üß œ±)
    ... | it ff ‚ü¶œÜ‚üßœ±‚â°ff = ‚ü¶œÜ‚üßœ±‚â°ff
    ... | it tt ‚ü¶œÜ‚üßœ±‚â°tt
      with map-‚àà-inv monCharFormula œÜ‚ààœÜs
    ... | œ±‚Ä≤ , œ±‚Ä≤‚ààttVals , œÜ‚â°monCharFormulaœ±‚Ä≤
      with filter-‚àà-inv vals œ±‚Ä≤‚ààttVals 
    ... | œ±‚Ä≤‚ààvals , fœ±‚Ä≤‚â°tt
      rewrite œÜ‚â°monCharFormulaœ±‚Ä≤
      with monCharFormula-completeness œ±‚Ä≤ œ± ‚ü¶œÜ‚üßœ±‚â°tt 
    ... | œ±‚Ä≤‚â§Vœ±
      with monf œ±‚Ä≤ œ± œ±‚Ä≤‚â§Vœ±
    ... | fœ±‚Ä≤‚â§fœ± rewrite fœ±‚Ä≤‚â°tt | fœ±‚â°ff = tt‚â§ùîπff-elim fœ±‚Ä≤‚â§fœ±
```

<!--

## Fragment `{‚à®, ‚àß, ‚áí, ‚ä§}`

This fragment is not semantically complete.

-->

## Fragment `{‚áë}` -- Sheffer's stroke {#Sheffer}

Since we cannot add a new connective,
we will define `‚áë` in terms of previous connectives.

```

_‚áë_ : Formula ‚Üí Formula ‚Üí Formula
œÜ ‚áë œà = ¬¨ (œÜ ‚àß œà)

data Formula[‚áë] : Formula ‚Üí Set where
  `_ : ‚àÄ p ‚Üí Formula[‚áë] (` p)
  _‚ü∞_ : ‚àÄ {œÜ œà} ‚Üí Formula[‚áë] œÜ ‚Üí Formula[‚áë] œà ‚Üí Formula[‚áë] (œÜ ‚áë œà)

[‚àß,¬¨]‚Üí[‚áë] : ‚àÄ {œÜ} ‚Üí Formula[¬¨‚àß] œÜ ‚Üí Formula
[‚àß,¬¨]‚Üí[‚áë] (` p) = ` p
[‚àß,¬¨]‚Üí[‚áë] (¬¨ viewœÜ) with [‚àß,¬¨]‚Üí[‚áë] viewœÜ
... | œà = œà ‚áë œà
[‚àß,¬¨]‚Üí[‚áë] (viewœÜ ‚àß viewœà) with [‚àß,¬¨]‚Üí[‚áë] viewœÜ | [‚àß,¬¨]‚Üí[‚áë] viewœà
... | œÜ' | œà' = let Œæ = œÜ' ‚áë œà' in Œæ ‚áë Œæ

[‚àß,¬¨]‚Üí[‚áë]-fragment : ‚àÄ {œÜ} (viewœÜ : Formula[¬¨‚àß] œÜ) ‚Üí
  Formula[‚áë] ([‚àß,¬¨]‚Üí[‚áë] viewœÜ)
[‚àß,¬¨]‚Üí[‚áë]-fragment (` p) = ` p
[‚àß,¬¨]‚Üí[‚áë]-fragment (¬¨ viewœÜ)
  with [‚àß,¬¨]‚Üí[‚áë]-fragment viewœÜ
... | viewœà = viewœà ‚ü∞ viewœà
[‚àß,¬¨]‚Üí[‚áë]-fragment (viewœÜ ‚àß viewœà)
  with [‚àß,¬¨]‚Üí[‚áë]-fragment viewœÜ | [‚àß,¬¨]‚Üí[‚áë]-fragment viewœà
... | viewœÜ' | viewœà' = let viewŒæ = viewœÜ' ‚ü∞ viewœà' in viewŒæ ‚ü∞ viewŒæ

[‚àß,¬¨]‚Üí[‚áë]-sound : ‚àÄ {œÜ} (viewœÜ : Formula[¬¨‚àß] œÜ) ‚Üí
  œÜ ‚ü∫ [‚àß,¬¨]‚Üí[‚áë] viewœÜ
[‚àß,¬¨]‚Üí[‚áë]-sound (` p) œ± = refl
[‚àß,¬¨]‚Üí[‚áë]-sound (¬¨ viewœÜ) œ±
  rewrite [‚àß,¬¨]‚Üí[‚áë]-sound viewœÜ œ±
  with ‚ü¶ [‚àß,¬¨]‚Üí[‚áë] viewœÜ ‚üß œ±
... | tt = refl
... | ff = refl
[‚àß,¬¨]‚Üí[‚áë]-sound (viewœÜ ‚àß viewœà) œ±
  rewrite [‚àß,¬¨]‚Üí[‚áë]-sound viewœÜ œ± | [‚àß,¬¨]‚Üí[‚áë]-sound viewœà œ±
  with ‚ü¶ [‚àß,¬¨]‚Üí[‚áë] viewœÜ ‚üß œ± | ‚ü¶ [‚àß,¬¨]‚Üí[‚áë] viewœà ‚üß œ±
... | tt | tt = refl
... | tt | ff = refl
... | ff | tt = refl
... | ff | ff = refl
```

# Solutions

!solutions
